{
  "hash": "b72a4f764213939bf0068af4f15f02bc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"stats-note\"\nformat: html\neditor: source\n---\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n# タイプIIトービットモデル {#sec-type2-tobit}\n\n## 要約\n\n- 賃金やECサイトでの購買金額のように、特定の回答者（e.g. 働いている人, ECサイトの利用者）しか観測できないデータを被説明変数とする場合に使える手法です\n- 被説明変数を観測できている人だけを対象として分析を行うと、セレクションバイアスが生じます\n- タイプIIトービットモデルを用いることで、セレクションバイアスを避けながら分析を行うことができます\n\n## タイプIIトービットモデルの概要\n\n　個人 $i$ の賃金を $W_i$ としたとき $\\log W_i = \\boldsymbol{X}_i^\\mathsf{T}\\boldsymbol{\\beta} + \\epsilon_{2i}$ で定まる回帰式を推定する問題を考えます。これは労働経済学ではミンサー型賃金関数と呼ばれ、年齢と所得の関係を調べる賃金プロファイルや、教育年数が所得に与える効果を調べるために用いられます[@川口2017; @大森_永瀬2021]。\n　実際の推定に当たっては、賃金 $W_i$ が就業者についてしか観測することができないことが問題となります。簡単な解決策として $W_i$ が観測されているデータだけを使って分析すること（完全ケース解析）が考えられますが、就業者と非就業者の属性に系統的な違いがあるなら、推定結果にバイアスが生じる可能性があります。また、非就業者について欠測値をゼロで埋めて $W_i = 0$ とすること（定数による代入）も適切ではありません。なぜなら、現在働いていない人でも働けば一定額の賃金が得られるはずだからです[@末石2015, p.111-113]。  \n　そこで、**タイプIIトービットモデル**では、賃金が観測されるかどうか（≒ その回答者が働いているかどうか）を予測するモデルと賃金を予測するモデルを組み合わせることで（@eq-Heckman1）、バイアスを補正します。  \n　タイプIIトービットモデルの推定方法としては、**Heckman の2段階推定**と最尤法が知られていますが、どちらも`sampleSelection` パッケージの `heckit()` 関数として実装されています。\n\n## Heckman の2段階推定\n\n　ここではタイプIIトービットモデルの推定法のうち、より簡単な Heckman の2段階推定について説明します。Heckman の2段階推定は、(1) 賃金 $W_i$ が観測されるかどうかを予測するプロビットモデル（就業決定関数）、(2) 賃金を予測する線形モデル（賃金関数）を、次のような手順で組み合わせます。  \n　まず、賃金が観測されていれば1、観測されていなければ0となるダミー変数 $D_i$ を被説明変数として使い、 $\\boldsymbol{Z}_i$ を説明変数とする、次のプロビットモデルを推定します。\n\n$$\n\\large\n\\begin{equation} \n\\begin{aligned}\n\\Phi(D_i) &= \\boldsymbol{Z}_i^\\mathsf{T}\\boldsymbol{\\gamma} + \\epsilon_{1i}\n\\end{aligned}\n\\end{equation} \n$$ {#eq-Heckman1} \n\n次に、推定されたプロビットモデルから $\\lambda(\\boldsymbol{Z}_i^\\mathsf{T} \\boldsymbol{\\gamma}) = \\phi(\\boldsymbol{Z}_i^\\mathsf{T}\\boldsymbol{\\gamma}) / \\Phi(\\boldsymbol{Z}_i^\\mathsf{T}\\boldsymbol{\\gamma})$ として定義される**逆ミルズ比**を推定します。最後に、逆ミルズ比を説明変数に加えた次のモデルを最小二乗法で推定することで、セレクションバイアスが補正された回帰係数 $\\boldsymbol{\\beta}$ の推定値を得ることができます。\n\n$$\n\\large\n\\begin{equation} \n\\begin{aligned}\n\\log W_i &= \\boldsymbol{X}_i^\\mathsf{T}\\boldsymbol{\\beta} \n+ \\sigma_{12}\\lambda(\\boldsymbol{Z}_i^\\mathsf{T} \\boldsymbol{\\gamma})\n+ \\epsilon_{2i}\n\\end{aligned}\n\\end{equation} \n$$ {#eq-Heckman2} \n\n## 使用上の注意点\n\nタイプIIトービットモデルの使用にあたり、次の2点に注意が必要です。\n\n1. 完全な多重共線性を避けるために、プロビットモデルの説明変数 $\\boldsymbol{Z}_i$ には、線形モデルの説明変数 $\\boldsymbol{X}_i$ に含まれていない変数を追加する必要がある\n2. 説明変数 $\\boldsymbol{Z}_i, \\boldsymbol{X}_i$ の欠測値には、タイプIIトービットモデルだけでは対応できない\n\n\n\n## Rによる実装\n\n::: {.example name=\"Heckman の2段階推定法\" #exm-Heckit-example1}\nここでは `sampleSelection` パッケージの `Mroz87`データを例にHeckman の2段階推定法を実装します。まずはサンプルデータを読み込みます。\n\n``` r\ndata(\"Mroz87\", package = \"sampleSelection\")\nMroz87 |> mutate()\n\nMroz87 <- Mroz87 |> \n  naniar::replace_with_na(replace = list(wage = 0)) |> \n  mutate(lwage = log(wage))\n\nMroz87 |> nrow()\n#> [1] 753\n\n# 労働参加 lfp = 0 の回答者は全て lwage が観測されています。\nMroz87 |> mutate(miss_lwage = is.na(lwage)) |> \n  janitor::tabyl(lfp, miss_lwage)\n#>  inlf FALSE TRUE\n#>     0     0  325\n#>     1   428    0\n```\n\n次に [`sampleSelection::heckit()`](https://cran.r-project.org/web/packages/sampleSelection/sampleSelection.pdf) 関数でタイプIIトービットモデルを推定します。\n\n``` r\nfit_heckit <- sampleSelection::heckit(\n  selection = lfp ~ educ + exper + I(exper^2) + nwifeinc + age + kids5 + kids618, # 就業決定関数\n  outcome =  lwage ~ educ + exper + I(exper^2),                                   # 賃金関数\n  data = Mroz87,\n  method = \"2step\"\n)\nsummary(fit_heckit)\n#> --------------------------------------------\n#> Tobit 2 model (sample selection model)\n#> 2-step Heckman / heckit estimation\n#> 753 observations (325 censored and 428 observed)\n#> 15 free parameters (df = 739)\n#> Probit selection equation:\n#>              Estimate Std. Error t value Pr(>|t|)    \n#> (Intercept)  0.270077   0.508593   0.531  0.59556    \n#> educ         0.130905   0.025254   5.183 2.81e-07 ***\n#> exper        0.123348   0.018716   6.590 8.34e-11 ***\n#> I(exper^2)  -0.001887   0.000600  -3.145  0.00173 ** \n#> nwifeinc    -0.012024   0.004840  -2.484  0.01320 *  \n#> age         -0.052853   0.008477  -6.235 7.61e-10 ***\n#> kids5       -0.868328   0.118522  -7.326 6.21e-13 ***\n#> kids618      0.036005   0.043477   0.828  0.40786    \n#> Outcome equation:\n#>               Estimate Std. Error t value Pr(>|t|)    \n#> (Intercept) -0.5781032  0.3050062  -1.895  0.05843 .  \n#> educ         0.1090655  0.0155230   7.026 4.83e-12 ***\n#> exper        0.0438873  0.0162611   2.699  0.00712 ** \n#> I(exper^2)  -0.0008591  0.0004389  -1.957  0.05068 .  \n#> Multiple R-Squared:0.1569,\tAdjusted R-Squared:0.149\n#>    Error terms:\n#>               Estimate Std. Error t value Pr(>|t|)\n#> invMillsRatio  0.03226    0.13362   0.241    0.809\n#> sigma          0.66363         NA      NA       NA\n#> rho            0.04861         NA      NA       NA\n#> --------------------------------------------\n```\n\n\n　この結果は春山[-@春山2023]が公開している `Heckit()` 関数を適用した結果と一致していました。ちなみに、`sampleSelection::heckit(method = \"2step\")` の結果に `broom::tidy()` を使うときは `broom::tidy(fit_heckit$lm)` で賃金関数の推定値を、`broom::tidy(fit_heckit$probit)` で就業決定関数の推定値を表示できるほか、`texreg::screenreg()` 関数にも対応しています。\n:::\n\n::: {.example name=\"タイプIIトービットモデルの限界効果\" #exm-Heckit-example3}\nここではタイプIIトービットモデルの限界効果をRで実装します。ダハナ, 勝又[-@ダハナ_勝又2023, p.139-140]と[`heckitmfx`](https://github.com/santosglauber/heckitmfx/tree/main/R)パッケージの [`heckitmfx::heckitmfx_log()`](https://github.com/santosglauber/heckitmfx/blob/main/R/heckitmfx_log.R) 関数の実装を参考に、 @eq-Heckit-mfx1 および @eq-Heckit-mfx3 の限界効果を関数として定義します。\n\n```{.r filename=\"heckitmfx.R\"}\n# メインの関数から呼び出されて、限界効果を推定する関数 ------------------------------------------------------------\nheckitmfx_compute <- function(\n    gamma, beta, betalambda, Z, ...\n    # type = c(\"unconditional\", \"conditional\", \"selection\")\n){\n  # 就業決定関数の予測値と逆ミルズ比の計算 ---------------------------------\n  alpha <- Z %*% gamma\n  lambda <- dnorm(alpha) / pnorm(alpha)\n  delta <- lambda * (lambda + alpha)\n  \n  # 限界効果の各項の計算 ---------------------\n  selection <- gamma[-1] * mean(lambda)\n  ei_2 <- gamma[-1] * betalambda * mean(delta)\n  \n  # ダミー変数用の処理 --------------\n  dummy_vars <- apply(Z[, -1], FUN = is_dummy, MARGIN = 2)\n  \n  if(sum(dummy_vars) >= 1){\n    terms_for_dummy_vars <- names(dummy_vars[dummy_vars]) |>\n      terms_for_dummy(Z, gamma, betalambda)\n    \n    # ダミー変数についての推定値に置換\n    ei_2[dummy_vars] <- terms_for_dummy_vars[1, ]\n    selection[dummy_vars] <- terms_for_dummy_vars[2, ]\n  }\n  \n  # 回帰係数と限界効果の各項をデータフレームにまとめます。\n  est <- merge(\n    data.frame(beta = beta[-1]), \n    data.frame(gamma = gamma[-1]), \n    by = \"row.names\", all = TRUE\n    ) |> \n    rename(term = \"Row.names\") |> \n    full_join(tibble::tibble(ei_2, term = names(ei_2)), by = join_by(term)) |> \n    full_join(tibble::tibble(selection, term = names(selection)), by = join_by(term))\n  \n  est[is.na(est)] <- 0\n  \n  # 限界効果の推定\n  res <- est |> \n    mutate(\n      term = as.character(term),\n      conditional = beta - ei_2,\n      unconditional = conditional + selection\n    ) |> \n    select(term, unconditional, conditional, selection, beta, gamma)\n  # 結果の出力 ---------------------------------\n  \n  return(res)\n}\n```\n\n次に、 @eq-Heckit-mfx2 と @eq-Heckit-mfx4 に基づいて説明変数 $\\boldsymbol{x}_j$ がダミー変数である場合の処理を実装します。\n\n```{.r filename=\"heckitmfx.R\"}\n# ダミー変数を判定する関数\nis_dummy <- function(x, unique_value = c(0, 1), na.rm = FALSE) {\n  if(na.rm) x <- na.omit(x)\n  res <- checkmate::test_set_equal(x = x, y = unique_value)\n  return(res)\n}\n\n# ダミー変数に関する間接効果の計算\nterms_for_dummy <- Vectorize(function(var_name, Z, gamma, betalambda){\n  fun_inv_mills <- \\(x) dnorm(x) / pnorm(x)\n  \n  z_1 <- z_0 <- colMeans(Z)\n  z_1[var_name] <- 1\n  z_0[var_name] <- 0\n  \n  delta_lambda <- betalambda * as.vector(fun_inv_mills(z_1 %*% gamma) - fun_inv_mills(z_0 %*% gamma))\n  delta_log_phi <- as.vector(pnorm(z_1 %*% gamma, log.p = TRUE) - pnorm(z_0 %*% gamma, log.p = TRUE))\n  \n  res <- rbind(delta_lambda, delta_log_phi) \n  return(res)\n}, vectorize.args = \"var_name\")\n```\n\n```{.r filename=\"heckitmfx.R\"}\n# モデルオブジェクトから限界効果を推定するメインの関数 ------------------------------------------------------------\n# ジェネリック関数の定義\nheckitmfx <- function(model, newdata = NULL, .params = NULL,...) UseMethod(\"heckitmfx\")\n\n# sampleSelection::heckit() 用のメソッド -----------------\nheckitmfx.selection <- function(model, newdata = NULL, .params = NULL, ...){\n  # 回帰係数の抽出 ---------------------------------\n  if(is.null(.params)){\n    coef_all <- coef(model) # 全ての回帰係数を取得  \n  }else{\n    # デルタ法の実装に使うための、回帰係数を任意の値で上書きする機能\n    coef_all <- .params # 引数 .params が指定されていた場合は .params で上書きする\n  }\n  \n  # 全ての説明変数の名前を抽出\n  all_vars <- names(coef_all) |> unique() %>% \n    subset(!(. %in% c(\"(Intercept)\", \"invMillsRatio\", \"sigma\", \"rho\")))\n  \n  # 賃金関数の回帰係数が始まる位置を特定する\n  start_beta <- which(names(coef_all) == \"(Intercept)\")[2]\n  \n  gamma <- coef_all[1:(start_beta - 1)] # 就業決定関数の回帰係数\n  \n  # 賃金関数の回帰係数\n  beta <- coef_all[start_beta:length(coef_all)] %>%\n    subset(!(names(.) %in% c(\"invMillsRatio\", \"sigma\", \"rho\")))\n  \n  betalambda <- coef_all %>% subset((names(.) %in% c(\"sigma\", \"rho\"))) |> prod()\n  \n  # 就業決定関数の計画行列の抽出 ---------------------------------\n  if(model$method == \"2step\"){\n    Z <- model.matrix(model$probit, data = newdata)\n    colnames(Z) <- str_remove(colnames(Z), \"XS\")\n  }else{\n    if(model$method == \"ml\"){\n      Z <- model.matrix(model$termsS, data = newdata)\n    }\n  }\n  # 限界効果の推定\n  res <- heckitmfx_compute(\n    gamma = gamma,\n    beta = beta,\n    betalambda = betalambda,\n    Z = Z\n  )\n  return(res)\n}\n```\n\n　@exm-Heckit-example1 で推定したモデル（fit_heckit）に対して `heckitmfx()` を実行すると、次のような結果が得られます。\n\n``` r\n#| paged-print: false\n# 2段階推定に基づく結果\nheckitmfx(fit_heckit) |> \n  mutate(across(where(is.numeric), .fns = \\(x) round(x, 5)))\n#>         term unconditional conditional selection     beta    gamma\n#> 1        age      -0.03854     0.00095  -0.03950  0.00000 -0.05285\n#> 2       educ       0.20453     0.10670   0.09782  0.10907  0.13090\n#> 3      exper       0.13384     0.04166   0.09217  0.04389  0.12335\n#> 4 I(exper^2)      -0.00224    -0.00083  -0.00141 -0.00086 -0.00189\n#> 5      kids5      -0.63321     0.01566  -0.64887  0.00000 -0.86833\n#> 6    kids618       0.02626    -0.00065   0.02691  0.00000  0.03600\n#> 7   nwifeinc      -0.00877     0.00022  -0.00898  0.00000 -0.01202\n```\n\n各列は次の値に対応します。\n\n-  `unconditional`： @eq-Heckit-mfx3 に基づく条件なしの平均限界効果 $\\overline{ME}(\\boldsymbol{x}_j)$。\n-  `conditional`： @eq-Heckit-mfx1 に基づく条件付き平均限界効果 $\\overline{ME}(\\boldsymbol{x}_j | Y_{1i}^* \\ge 0)$。\n-  `selection`： @eq-Heckit-mfx3 第3項の間接効果 $e_{II} = \\gamma_j \\lambda(\\boldsymbol{Z}_i^\\mathsf{T}\\boldsymbol{\\gamma})$\n-  `beta`：賃金関数の回帰係数の推定値 $\\hat{\\boldsymbol{\\beta}}$\n-  `gamma`：就業決定関数の回帰係数の推定値 $\\hat{\\boldsymbol{\\gamma}}$\n:::\n\n::: {.example name=\"ブートストラップ法を使った限界効果の標準誤差の推定\" #exm-Heckit-example4}\nここでは @exm-Heckit-example3 で推定したタイプIIトービットモデルの限界効果について、ブートストラップ法を使った標準誤差の推定と検定を試みたいと思います。 @exm-Heckit-example1 に引き続いて `data_chap7` とダハナ, 勝又[-@ダハナ_勝又2023, p.137]のモデルを使用し、 @exm-Heckit-example2 で実装した `heckitmfx()` 関数で限界効果を推定するまでをひとまとめにしたラッパー関数を定義します。\n\n``` r\nest_heckit_mfx <- function(data){\n  mod <- sampleSelection::heckit(\n    selection = lfp ~ educ + exper + I(exper^2) + nwifeinc + age + kids5 + kids618, # 就業決定関数\n    outcome =  lwage ~ educ + exper + I(exper^2),                                      # 賃金関数\n    data = data,\n    method = \"2step\"\n  )\n  res <- heckitmfx(mod, newdata = data)  \n  return(res)\n}\n```\n\n次に、`slice_sample()` 関数で復元抽出を行い、反復回数を $B = 1000$ としてブートストラップ統計量を推定します。\n\n``` r\nset.seed(123)\ntictoc::tic() # 参考までに実行時間を計測しておきます。\n\nheckitmfx_with_boot <- map(\n  .x = 1:1000, \n  .f = \\(x) est_heckit_mfx(Mroz87 |> slice_sample(prop = 1, replace = TRUE))\n  ) |>\n  bind_rows(.id = \"Iteration\")\n\ntictoc::toc()\n#> 26.45 sec elapsed\n```\n\nここでは [`ggdist::stat_pointinterval()`](https://mjskay.github.io/ggdist/reference/stat_pointinterval.html) 関数を使ってブートストラップ統計量の分布を可視化してみましょう。\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nheckitmfx_with_boot |> \n  select(Iteration:selection) |> \n  pivot_longer(unconditional:selection, names_to = \"type\", values_to = \"estimate\") |> \n  ggplot(aes(x = estimate, y = term)) +\n  geom_vline(xintercept = 0, color = \"gray60\", linetype = 2) +\n  ggdist::stat_pointinterval(\n    color = my_color, alpha = 0.7, \n    point_interval = \"mean_qi\", # `summarise_boot` と一致するように点推定を平均値とします。\n    .width = c(0.95, 0.99)\n    ) + \n  facet_wrap(~type)\n```\n\n::: {.cell-output-display}\n![](typeII-tobit_files/figure-html/unnamed-chunk-3-1.png){fig-align='center' width=931.2}\n:::\n:::\n\n\n @sec-resampling-methods 章 @sec-bootstrap-methods 節の @eq-boot-1 を使ってブートストラップ統計量を集計し、 @eq-boot-3 の分位点法を使って$p$-値を計算します。ここでは `heckitmfx()` で得られる3種類の限界効果について、それぞれ標準誤差と$p$-値を計算しています。\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsummarise_boot <- function(var){\n  heckitmfx_with_boot |> \n    summarise(\n    type = var,\n    estimate = mean(.data[[var]]),\n    std.error = sd(.data[[var]]),                                        # 標準誤差\n    p.value = 2 * pmin(mean(.data[[var]] <= 0), mean(.data[[var]] > 0)), # 分位点法によるp-値\n    .lower = quantile(.data[[var]], 0.025),\n    .upper = quantile(.data[[var]], 0.975),\n    .by = term\n  )\n}\n\nsummary_boot <- map(\n  .x = c(\"unconditional\", \"conditional\", \"selection\"), \n  .f = \\(x) summarise_boot(x)\n  ) |> \n  bind_rows()\n\nsummary_boot |> print(n = 5)\n#> # A tibble: 21 × 7\n#>   term       type          estimate std.error p.value   .lower   .upper\n#>   <chr>      <chr>            <dbl>     <dbl>   <dbl>    <dbl>    <dbl>\n#> 1 age        unconditional -0.0392   0.00857        0 -0.0568  -0.0237 \n#> 2 educ       unconditional  0.206    0.0251         0  0.157    0.256  \n#> 3 exper      unconditional  0.135    0.0214         0  0.0974   0.179  \n#> 4 I(exper^2) unconditional -0.00224  0.000626       0 -0.00352 -0.00112\n#> 5 kids5      unconditional -0.642    0.125          0 -0.906   -0.404  \n#> # ℹ 16 more rows\n```\n:::\n\n\n　最後に推定結果を比較しやすいように、`texreg::screenreg()` を模したフォーマットに変換してみましょう。推定結果を比較すると、年齢 `Age` や `Crossbuying` などように一貫して限界効果が統計的に有意な変数がある一方で、性別 `Sex` については総効果 `dydx` では有意でなくても間接効果は有意であるという結果になっていることが興味深く感じられます（@tbl-bootstrap-mfx-table1）。\n\n\n::: {#tbl-bootstrap-mfx-table1 .cell layout-align=\"center\" tbl-cap='ブートストラップ法による推定結果'}\n<table class=\"table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;border-bottom: 0;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> term </th>\n   <th style=\"text-align:left;\"> unconditional </th>\n   <th style=\"text-align:left;\"> conditional </th>\n   <th style=\"text-align:left;\"> selection </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> age </td>\n   <td style=\"text-align:left;\"> -0.0392***<br>(0.0086) </td>\n   <td style=\"text-align:left;\"> 0.0010 <br>(0.0046) </td>\n   <td style=\"text-align:left;\"> -0.0402***<br>(0.0069) </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> educ </td>\n   <td style=\"text-align:left;\"> 0.2059***<br>(0.0251) </td>\n   <td style=\"text-align:left;\"> 0.1060***<br>(0.0141) </td>\n   <td style=\"text-align:left;\"> 0.0999***<br>(0.0203) </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> exper </td>\n   <td style=\"text-align:left;\"> 0.1350***<br>(0.0214) </td>\n   <td style=\"text-align:left;\"> 0.0417**<br>(0.0152) </td>\n   <td style=\"text-align:left;\"> 0.0933***<br>(0.0159) </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> I(exper^2) </td>\n   <td style=\"text-align:left;\"> -0.0022***<br>(0.0006) </td>\n   <td style=\"text-align:left;\"> -0.0008*<br>(0.0004) </td>\n   <td style=\"text-align:left;\"> -0.0014**<br>(0.0005) </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> kids5 </td>\n   <td style=\"text-align:left;\"> -0.6424***<br>(0.1248) </td>\n   <td style=\"text-align:left;\"> 0.0168 <br>(0.0756) </td>\n   <td style=\"text-align:left;\"> -0.6592***<br>(0.0996) </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> kids618 </td>\n   <td style=\"text-align:left;\"> 0.0276 <br>(0.0344) </td>\n   <td style=\"text-align:left;\"> -0.0008 <br>(0.0050) </td>\n   <td style=\"text-align:left;\"> 0.0284 <br>(0.0350) </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> nwifeinc </td>\n   <td style=\"text-align:left;\"> -0.0091*<br>(0.0040) </td>\n   <td style=\"text-align:left;\"> 0.0003 <br>(0.0012) </td>\n   <td style=\"text-align:left;\"> -0.0094*<br>(0.0040) </td>\n  </tr>\n</tbody>\n<tfoot>\n<tr><td style=\"padding: 0; \" colspan=\"100%\"><span style=\"font-style: italic;\">Note: </span></td></tr>\n<tr><td style=\"padding: 0; \" colspan=\"100%\">\n<sup></sup> 括弧内はブートストラップ法による標準誤差</td></tr>\n<tr><td style=\"padding: 0; \" colspan=\"100%\">\n<sup></sup> Signif. codes:  0 ‘\\***’ 0.001 ‘\\**’ 0.01 ‘\\*’ 0.05 ‘.’ 0.1 ‘ ’ 1</td></tr>\n</tfoot>\n</table>\n:::\n\n:::\n\n# 参考文献\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "supporting": [
      "typeII-tobit_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}