# タイプIIトービットモデル {#sec-type2-tobit}

```{r, echo=FALSE}
pacman::p_load(tidyverse, broom, patchwork, colorspace, cols4all, janitor, broom, formattable, here, fs)
theme_set(theme_bw())
my_color <- colorspace::sequential_hcl(n = 6, palette = "Teal")[2]
color_set <- viridisLite::viridis(n = 6, begin = .2, end = .9)
source(here::here("R", "opts_template.R"))
use("magrittr", c("%$%", "%T>%"))
```

## 要約

- 賃金やECサイトでの購買金額のように、特定の回答者（e.g. 働いている人, ECサイトの利用者）しか観測できないデータを被説明変数とする場合に使える手法です
- 被説明変数を観測できている人だけを対象として分析を行うと、セレクションバイアスが生じます
- タイプIIトービットモデルを用いることで、セレクションバイアスを避けながら分析を行うことができます

## タイプIIトービットモデルの概要

　個人 $i$ の賃金を $W_i$ として $\log W_i = \boldsymbol{X}_i^\mathsf{T}\boldsymbol{\beta} + \epsilon_{2i}$ で定まる回帰モデルを推定する問題を考えます。これは労働経済学ではミンサー型賃金関数と呼ばれ、年齢と所得の関係を調べる賃金プロファイルや、教育年数が所得に与える効果を調べるために用いられます[@川口2017; @大森_永瀬2021]。賃金関数の推定に当たっては、賃金 $W_i$ が就業者についてしか観測することができないことが問題となります（@fig-unobserved-wages）。  
　このような状況は、就労状況に関する社会調査で頻繁に見られます。例えばリクルートワークス研究所が実施している[「全国就業実態パネル調査」](https://www.works-i.com/surveys/panel-surveys.html)でも、今現在働いている回答者は仕事からの年収について質問される一方で、今現在働いていない回答者は質問されない（設問の対象から外れる）ことになっています。


```{r}
#| label: fig-unobserved-wages
#| echo: false
#| out-width: 70%
#| fig-align: center
#| fig-cap: "一部の回答者の賃金が観測できない状況"
knitr::include_graphics("Image/賃金が観測できない状況.png")
```

　働いていない回答者からすれば、仕事からの年収について質問されても答えようがないので、欠測値になるのは仕方のないことです。しかし、通常の回帰分析は被説明変数に欠測値がないことが前提になっているので、何かしらの対処が必要になります。  
　欠測値に対する簡単な対処法として、賃金 $W_i$ が観測されているデータだけを使って分析すること（完全ケース解析）が考えられますが、就業者と非就業者の属性に系統的な違い（例：女性や高齢者の非就業率が高い）があるなら、推定結果にバイアス（選択バイアス）が生じる可能性があります。また、非就業者について欠測値を0で埋めること（定数代入）も適切ではありません。なぜなら、現在働いていない人でも働けば一定額の賃金が得られるはずだからです[@末石2015, p.111-113]。  
　このような課題に対して、完全ケース解析や定数代入を避けて分析を実施する方法の1つが**タイプIIトービットモデル**です。タイプIIトービットモデルでは、賃金が観測されるかどうか（≒ その回答者が働いているかどうか）を予測するプロビットモデルと、賃金を予測する線形モデルを組み合わせることで、選択バイアスを補正します(@fig-type2-tobit)。タイプIIトービットモデルの推定方法としては、**Heckman の2段階推定**と最尤法が知られていますが、どちらも`sampleSelection` パッケージの `heckit()` 関数として実装されています。

```{r}
#| label: fig-type2-tobit
#| echo: false
#| out-width: 70%
#| fig-align: center
#| fig-cap: "タイプIIトービットモデルの模式図"
knitr::include_graphics("Image/タイプIIトービットモデルの模式図.png")
```

## Heckman の2段階推定

　ここではタイプIIトービットモデルの推定法のうち、より簡単な Heckman の2段階推定について説明します。Heckman の2段階推定は、(1) 賃金 $W_i$ が観測されるかどうかを予測するプロビットモデル（就業決定関数）、(2) 賃金を予測する線形モデル（賃金関数）を、次のような手順で組み合わせます。  
　まず、賃金が観測されていれば1、観測されていなければ0となるダミー変数 $D_i$ を被説明変数として使い、 $\boldsymbol{Z}_i$ を説明変数とする、次のプロビットモデルを推定します。

$$
\large
\begin{equation} 
\begin{aligned}
\Phi(D_i) &= \boldsymbol{Z}_i^\mathsf{T}\boldsymbol{\gamma} + \epsilon_{1i}
\end{aligned}
\end{equation} 
$$ {#eq-Heckman1} 

次に、推定されたプロビットモデルから $\lambda(\boldsymbol{Z}_i^\mathsf{T} \boldsymbol{\gamma}) = \phi(\boldsymbol{Z}_i^\mathsf{T}\boldsymbol{\gamma}) / \Phi(\boldsymbol{Z}_i^\mathsf{T}\boldsymbol{\gamma})$ として定義される**逆ミルズ比**を推定します。最後に、逆ミルズ比を説明変数に加えた次のモデルを最小二乗法で推定することで、セレクションバイアスが補正された回帰係数 $\boldsymbol{\beta}$ の推定値を得ることができます。

$$
\large
\begin{equation} 
\begin{aligned}
\log W_i &= \boldsymbol{X}_i^\mathsf{T}\boldsymbol{\beta} 
+ \sigma_{12}\lambda(\boldsymbol{Z}_i^\mathsf{T} \boldsymbol{\gamma})
+ \epsilon_{2i}
\end{aligned}
\end{equation} 
$$ {#eq-Heckman2} 

## 使用上の注意点

タイプIIトービットモデルの使用にあたり、次の2点に注意が必要です。

1. プロビットモデルの説明変数 $\boldsymbol{Z}_i$ には、線形モデルの説明変数 $\boldsymbol{X}_i$ に含まれていない変数を、少なくとも追加する必要がある

具体的には、線形モデルの説明変数 $\boldsymbol{X}_i$ には教育年数と年齢を使い、プロビットモデルの説明変数 $\boldsymbol{Z}_i$ には教育年数と年齢に加えて子どもの人数を使う、といった配慮が必要です。

2. 説明変数 $\boldsymbol{Z}_i, \boldsymbol{X}_i$ の欠測値には、タイプIIトービットモデルだけでは対応できない

職場の業種や現職の勤続年数、職種、肩書など、賃金以外にも非就業者については観測できない変数は数多くあります。しかし、タイプIIトービットモデルで対応できるのは被説明変数の欠測だけなので、就業者と非就業者の両方で観測できる説明変数だけを使うか、他の方法で補完するといった対応が必要です

## Rによる実装

::: {.example name="Heckman の2段階推定法" #exm-Heckit-example1}
ここでは `sampleSelection` パッケージの `Mroz87`データを例に、次に [`sampleSelection::heckit()`](https://cran.r-project.org/web/packages/sampleSelection/sampleSelection.pdf) 関数を使って Heckman の2段階推定法を実装します。`Mroz87` データは1975年に実施された Panel Study of Income Dynamics をもとにしたデータです。753名の既婚女性のデータが記録されており、内428名が就業者、残る325名が非就業者です。`Mroz87` には就業状態 `lfp や賃金 `wage`、教育年数 `educ` や労働市場経験年数 `exper`、配偶者の賃金 `huswage` が収録されており、今回はこれに Heckman の2段階推定を組み合わせて賃金関数を推定します。  
　まずはサンプルデータを読み込みます。

``` r
data("Mroz87", package = "sampleSelection")
Mroz87 |> dim()
#> [1] 753  22
```

`Mroz87` データでは非就業者の賃金は全て0（`wage = 0`）として記録されているのですが、ここでは処理を明確にするために非就業者の賃金は欠測値 `NA` に置き換え、さらに対数賃金を計算しておきます。

``` r
Mroz87 <- Mroz87 |> 
  naniar::replace_with_na(replace = list(wage = 0)) |> 
  mutate(lwage = log(wage)) 

# 労働参加 lfp = 0 の回答者は全て lwage が観測されています。
Mroz87 |> mutate(miss_lwage = is.na(lwage)) |> 
  janitor::tabyl(lfp, miss_lwage)
#>  inlf FALSE TRUE
#>     0     0  325
#>     1   428    0
```


次に [`sampleSelection::heckit()`](https://cran.r-project.org/web/packages/sampleSelection/sampleSelection.pdf) 関数でタイプIIトービットモデルを推定します。`heckit()` 関数を使うときは、`selection` 引数に就業決定関数の回帰式を指定し、`outcome` 引数に賃金関数の回帰式を指定します。今回は、典型的なミンサー型賃金関数で使われる教育年数 `educ` と経験年数 `exper` およびその2乗項に加えて配偶者の賃金 `huswage` を説明変数として使い、就業決定関数ではさらに年齢 `age` と子どもの人数（`kids5` および `kids618`）を説明変数として使用します。また、ここでは Heckman の2段階推定を使うので `method = "2step"` を指定します。

``` r
fit_heckit <- sampleSelection::heckit(
  selection = lfp ~ educ + exper + I(exper^2) + huswage + age + kids5 + kids618, # 就業決定関数
  outcome = lwage ~ educ + exper + I(exper^2) + huswage,                         # 賃金関数
  data = Mroz87,
  method = "2step"
)
summary(fit_heckit)
#> --------------------------------------------
#> Tobit 2 model (sample selection model)
#> 2-step Heckman / heckit estimation
#> 753 observations (325 censored and 428 observed)
#> 16 free parameters (df = 738)
#> Probit selection equation:
#>               Estimate Std. Error t value Pr(>|t|)    
#> (Intercept)  0.3606478  0.5057097   0.713   0.4760    
#> educ         0.1248354  0.0248294   5.028 6.24e-07 ***
#> exper        0.1260740  0.0186842   6.748 3.04e-11 ***
#> I(exper^2)  -0.0019245  0.0006001  -3.207   0.0014 ** 
#> huswage     -0.0255439  0.0126406  -2.021   0.0437 *  
#> age         -0.0547300  0.0084083  -6.509 1.40e-10 ***
#> kids5       -0.8650260  0.1180205  -7.329 6.08e-13 ***
#> kids618      0.0285095  0.0434365   0.656   0.5118    
#> Outcome equation:
#>               Estimate Std. Error t value Pr(>|t|)    
#> (Intercept) -0.4472713  0.3122183  -1.433   0.1524    
#> educ         0.0955365  0.0168361   5.675    2e-08 ***
#> exper        0.0370433  0.0166119   2.230   0.0261 *  
#> I(exper^2)  -0.0006878  0.0004465  -1.540   0.1239    
#> huswage      0.0192415  0.0098639   1.951   0.0515 .  
#> Multiple R-Squared:0.1643,	Adjusted R-Squared:0.1544
#>    Error terms:
#>               Estimate Std. Error t value Pr(>|t|)
#> invMillsRatio -0.06114    0.14170  -0.431    0.666
#> sigma          0.66171         NA      NA       NA
#> rho           -0.09240         NA      NA       NA
#> --------------------------------------------
```

　推定結果は `Probit selection equation` が就業決定関数の結果を、`Outcome equation` が賃金関数の結果を表しています。今回の推定結果を見ると、妻の教育年数 `educ` と経験年数 `exper` が伸びるほど就業率と賃金が高くなり、配偶者の賃金 `huswage` が高くなるほど妻の就業率は低下するものの、賃金には影響を与えないことが読み取れます^[分析結果の解釈方法については、春山[-@春山2023]なども参照してください。]。  
　ちなみに、`sampleSelection::heckit(method = "2step")` の結果に `broom::tidy()` を使うときは `broom::tidy(fit_heckit$lm)` で賃金関数の推定値を、`broom::tidy(fit_heckit$probit)` で就業決定関数の推定値を表示できるほか、`texreg::screenreg()` 関数にも対応しています。
:::

## タイプIIトービットモデルの限界効果

　計量経済学の実証論文では、ロジスティック回帰やプロビットモデルの推定結果を**限界効果**（marginal effect）に変換してから掲載することがよく行われます。限界効果とは、ある説明変数 $\boldsymbol{x}_j$ が僅かに変化したときに、被説明変数や予測確率がどの程度増減するかを表すもので、回帰式を説明変数 $\boldsymbol{x}_{ij}$ で偏微分したものとして定義されます。  
　タイプIIトービットモデルについても、次式によって限界効果を計算できることが知られています[@ダハナ_勝又2023, pp.139-140; @Hoffmann_Kassouf2005]。

$$
\large
\begin{equation}
\begin{aligned}
ME(x_{ij}) &= \frac{\partial}{\partial x_{i, j}}\log E[W_i]
= \underbrace{
\beta_j - \gamma_j \sigma_{12} \delta_i}_{e_I}
+ \underbrace{
\gamma_j \lambda(\boldsymbol{Z}_i^\mathsf{T}\boldsymbol{\gamma})
}_{e_{II}}\\
\delta_i &= \lambda(\boldsymbol{Z}_i^\mathsf{T}\boldsymbol{\gamma})
[\boldsymbol{Z}_i^\mathsf{T}\boldsymbol{\gamma} 
+ \lambda(\boldsymbol{Z}_i^\mathsf{T}\boldsymbol{\gamma})]
\end{aligned}
\end{equation}
$$ {#eq-Heckit-mfx3}

@eq-Heckit-mfx3 の限界効果には、条件付き限界効果 $e_I$、間接効果 $e_{II}$、条件なしの限界効果 $ME(x_{ij})$ の3通りに分解できるという特徴があり、それぞれの項には次のような意味があります[@Hoffmann_Kassouf2005]。

- $e_I$ **条件付き限界効果**（conditional marginal effect）： 説明変数 $\boldsymbol{x}_j$ の変化が就業者の賃金に与える効果を表す
- $e_{II}$ **間接効果**：説明変数 $\boldsymbol{x}_j$ の変化が、就業率の変化を通じて間接的に賃金を変化させる効果
- $ME(x_{ij})$ **条件なしの限界効果**（unconditional marginal effect）：説明変数 $\boldsymbol{x}_j$ の変化が就業者と非就業者の全体の賃金に与える効果を表す

　例えば Hoffmann, Kassouf[-@Hoffmann_Kassouf2005, p.12]は、実証分析に @eq-Heckit-mfx3 の分解を利用することで、ブラジルの女性の教育年数が1年伸びることが、勤労女性の収入を11.6%上昇させると同時に、女性の労働市場参加率を5.2%増加させることで、女性全体の所得を17.4％増加させる効果を持つと報告しています。　　
　このように、教育年数が収入に与える効果をより豊かな洞察をもたらす形で提示できることは、タイプIIトービットモデルを用いる利点の1つだと言えるでしょう。

::: {.example name="タイプIIトービットモデルの限界効果" #exm-Heckit-example3}
ここではタイプIIトービットモデルの限界効果をRで実装します。ダハナ, 勝又[-@ダハナ_勝又2023, p.139-140]と Hoffmann, Kassouf[-@Hoffmann_Kassouf2005]、そして [`heckitmfx`](https://github.com/santosglauber/heckitmfx/tree/main/R)パッケージの [`heckitmfx::heckitmfx_log()`](https://github.com/santosglauber/heckitmfx/blob/main/R/heckitmfx_log.R) 関数の実装を参考に、@eq-Heckit-mfx3 の限界効果をRの関数として実装します。

```{r filename="heckitmfx.R"}
# メインの関数から呼び出されて、限界効果を推定する関数 ------------------------------------------------------------
heckitmfx_compute <- function(
    gamma, beta, betalambda, Z, ...
    # type = c("unconditional", "conditional", "selection")
){
  # 就業決定関数の予測値と逆ミルズ比の計算 ---------------------------------
  alpha <- Z %*% gamma
  lambda <- dnorm(alpha) / pnorm(alpha)
  delta <- lambda * (lambda + alpha)
  
  # 限界効果の各項の計算 ---------------------
  selection <- gamma[-1] * mean(lambda)
  ei_2 <- gamma[-1] * betalambda * mean(delta)
  
  # ダミー変数用の処理 --------------
  dummy_vars <- apply(Z[, -1], FUN = is_dummy, MARGIN = 2)
  
  if(sum(dummy_vars) >= 1){
    terms_for_dummy_vars <- names(dummy_vars[dummy_vars]) |>
      terms_for_dummy(Z, gamma, betalambda)
    
    # ダミー変数についての推定値に置換
    ei_2[dummy_vars] <- terms_for_dummy_vars[1, ]
    selection[dummy_vars] <- terms_for_dummy_vars[2, ]
  }
  
  # 回帰係数と限界効果の各項をデータフレームにまとめます。
  est <- merge(
    data.frame(beta = beta[-1]), 
    data.frame(gamma = gamma[-1]), 
    by = "row.names", all = TRUE
    ) |> 
    rename(term = "Row.names") |> 
    full_join(tibble::tibble(ei_2, term = names(ei_2)), by = join_by(term)) |> 
    full_join(tibble::tibble(selection, term = names(selection)), by = join_by(term))
  
  est[is.na(est)] <- 0
  
  # 限界効果の推定
  res <- est |> 
    mutate(
      term = as.character(term),
      conditional = beta - ei_2,
      unconditional = conditional + selection
    ) |> 
    select(term, unconditional, conditional, selection, beta, gamma)
  # 結果の出力 ---------------------------------
  
  return(res)
}
```

次に、Hoffmann, Kassouf[-@Hoffmann_Kassouf2005]に基づいて説明変数 $\boldsymbol{x}_j$ がダミー変数である場合の処理を実装します。

```{r filename="heckitmfx.R"}
# ダミー変数を判定する関数
is_dummy <- function(x, unique_value = c(0, 1), na.rm = FALSE) {
  if(na.rm) x <- na.omit(x)
  res <- checkmate::test_set_equal(x = x, y = unique_value)
  return(res)
}

# ダミー変数に関する間接効果の計算
terms_for_dummy <- Vectorize(function(var_name, Z, gamma, betalambda){
  fun_inv_mills <- \(x) dnorm(x) / pnorm(x)
  
  z_1 <- z_0 <- colMeans(Z)
  z_1[var_name] <- 1
  z_0[var_name] <- 0
  
  delta_lambda <- betalambda * as.vector(fun_inv_mills(z_1 %*% gamma) - fun_inv_mills(z_0 %*% gamma))
  delta_log_phi <- as.vector(pnorm(z_1 %*% gamma, log.p = TRUE) - pnorm(z_0 %*% gamma, log.p = TRUE))
  
  res <- rbind(delta_lambda, delta_log_phi) 
  return(res)
}, vectorize.args = "var_name")
```

最後に、限界効果を推定するメインの関数である `heckitmfx()` 関数を実装します。

```{r filename="heckitmfx.R"}
# モデルオブジェクトから限界効果を推定するメインの関数 ------------------------------------------------------------
heckitmfx <- function(model, newdata = NULL, .params = NULL, ...){
  # 回帰係数の抽出 ---------------------------------
  if(is.null(.params)){
    coef_all <- coef(model) # 全ての回帰係数を取得  
  }else{
    # デルタ法の実装に使うための、回帰係数を任意の値で上書きする機能
    coef_all <- .params # 引数 .params が指定されていた場合は .params で上書きする
  }
  
  # 全ての説明変数の名前を抽出
  all_vars <- names(coef_all) |> unique() %>% 
    subset(!(. %in% c("(Intercept)", "invMillsRatio", "sigma", "rho")))
  
  # 賃金関数の回帰係数が始まる位置を特定する
  start_beta <- which(names(coef_all) == "(Intercept)")[2]
  
  gamma <- coef_all[1:(start_beta - 1)] # 就業決定関数の回帰係数
  
  # 賃金関数の回帰係数
  beta <- coef_all[start_beta:length(coef_all)] %>%
    subset(!(names(.) %in% c("invMillsRatio", "sigma", "rho")))
  
  betalambda <- coef_all %>% subset((names(.) %in% c("sigma", "rho"))) |> prod()
  
  # 就業決定関数の計画行列の抽出 ---------------------------------
  if(model$method == "2step"){
    Z <- model.matrix(model$probit, data = newdata)
    colnames(Z) <- str_remove(colnames(Z), "XS")
  }else{
    if(model$method == "ml"){
      Z <- model.matrix(model$termsS, data = newdata)
    }
  }
  # 限界効果の推定
  res <- heckitmfx_compute(
    gamma = gamma,
    beta = beta,
    betalambda = betalambda,
    Z = Z
  )
  return(res)
}
```

　@exm-Heckit-example1 で推定したモデル（fit_heckit）に対して `heckitmfx()` を実行すると、次のような結果が得られます。

``` r
heckitmfx(fit_heckit) |> 
  mutate(across(where(is.numeric), .fns = \(x) round(x, 5)))
#>         term unconditional conditional selection     beta    gamma
#> 1        age      -0.04270    -0.00187  -0.04083  0.00000 -0.05473
#> 2       educ       0.19293     0.09981   0.09313  0.09554  0.12484
#> 3      exper       0.13541     0.04136   0.09405  0.03704  0.12607
#> 4    huswage      -0.00069     0.01837  -0.01906  0.01924 -0.02554
#> 5 I(exper^2)      -0.00219    -0.00075  -0.00144 -0.00069 -0.00192
#> 6      kids5      -0.67489    -0.02959  -0.64531  0.00000 -0.86503
#> 7    kids618       0.02224     0.00098   0.02127  0.00000  0.02851
```

なお、`heckitmfx()` 関数の出力の各列は次の値に対応しています。

-  `unconditional`： 条件なしの平均限界効果 $\overline{ME}(\boldsymbol{x}_j)$。
-  `conditional`： 条件付き平均限界効果 $\overline{ME}(\boldsymbol{x}_j | Y_{1i}^* \ge 0)$。
-  `selection`： 間接効果の平均値 $e_{II} = \gamma_j \lambda(\boldsymbol{Z}_i^\mathsf{T}\boldsymbol{\gamma})$
-  `beta`：賃金関数の回帰係数の推定値 $\hat{\boldsymbol{\beta}}$
-  `gamma`：就業決定関数の回帰係数の推定値 $\hat{\boldsymbol{\gamma}}$
:::

::: {.example name="ブートストラップ法を使った限界効果の標準誤差の推定" #exm-Heckit-example4}
ここでは @exm-Heckit-example3 で推定したタイプIIトービットモデルの限界効果について、ブートストラップ法を使った標準誤差の推定と検定を試みたいと思います。まず、 @exm-Heckit-example1 で実装したモデル推定し、@exm-Heckit-example3 で実装した `heckitmfx()` 関数で限界効果を推定するまでの操作を、ひとまとめにしたラッパー関数を定義します。

```{r}
est_heckit_mfx <- function(data){
  mod <- sampleSelection::heckit(
    selection = lfp ~ educ + exper + I(exper^2) + huswage + age + kids5 + kids618, # 就業決定関数
    outcome = lwage ~ educ + exper + I(exper^2) + huswage,                         # 賃金関数
    data = data,
    method = "2step"
  )
  res <- heckitmfx(mod, newdata = data)  
  return(res)
}
```

次に、`slice_sample()` 関数で復元抽出を行い、反復回数を1,000回でブートストラップ法を実行します。

``` r
set.seed(123)
tictoc::tic() # 参考までに実行時間を計測しておきます。

heckitmfx_with_boot <- map(
  .x = 1:1000, 
  .f = \(x) est_heckit_mfx(Mroz87 |> slice_sample(prop = 1, replace = TRUE))
  ) |>
  bind_rows(.id = "Iteration")

tictoc::toc()
#> 15.565 sec elapsed
```

ここでは [`ggdist::stat_pointinterval()`](https://mjskay.github.io/ggdist/reference/stat_pointinterval.html) 関数を使ってブートストラップ統計量の分布を可視化してみましょう。

```{r}
#| echo: false
# heckitmfx_with_boot |> write_csv(here::here("result", "heckitmfx_with_boot_mroz.csv"))
heckitmfx_with_boot <- read_csv(here::here("result", "heckitmfx_with_boot_mroz.csv"), show_col_types = FALSE)
```

```{r}
#| opts-label: two_grahp
heckitmfx_with_boot |> 
  select(Iteration:selection) |> 
  pivot_longer(unconditional:selection, names_to = "type", values_to = "estimate") |> 
  ggplot(aes(x = estimate, y = term)) +
  geom_vline(xintercept = 0, color = "gray60", linetype = 2) +
  ggdist::stat_pointinterval(
    color = my_color, alpha = 0.7, 
    point_interval = "mean_qi", # `summarise_boot` と一致するように点推定を平均値とします。
    .width = c(0.95, 0.99)
    ) + 
  facet_wrap(~type)
```

次に、`heckitmfx()` で得られる3種類の限界効果について、ブートストラップ統計量を集計して、それぞれ標準誤差分位点法による$p$-値を計算します。なお、ブートストラップ法やブートストラップ法での信頼区間と$p$-値の計算方法については末石[-@末石2015, p.140]、Efron & Hastie[-@CASI2016]、Taddy[-@taddy2019]および Bodory et al.[@Bodory_et_al2020, p.16]を参照してください。

```{r}
#| paged-print: false
summarise_boot <- function(res_boot, var){
  res_boot |> 
    summarise(
    type = var,
    estimate = mean(.data[[var]]),
    std.error = sd(.data[[var]]),                                        # 標準誤差
    p.value = 2 * pmin(mean(.data[[var]] <= 0), mean(.data[[var]] > 0)), # 分位点法によるp-値
    .lower = quantile(.data[[var]], 0.025),
    .upper = quantile(.data[[var]], 0.975),
    .by = term
  )
}

summary_boot <- map(
  .x = c("unconditional", "conditional", "selection"), 
  .f = \(x) summarise_boot(heckitmfx_with_boot, x)
  ) |> 
  bind_rows()
```

　最後に推定結果を比較しやすいように、`texreg::screenreg()` を模したフォーマットに変換してみましょう。推定結果を比較すると、年齢 `Age` や `Crossbuying` などように一貫して限界効果が統計的に有意な変数がある一方で、性別 `Sex` については総効果 `dydx` では有意でなくても間接効果は有意であるという結果になっていることが興味深く感じられます（@tbl-bootstrap-mfx-table1）。

```{r}
#| label: tbl-bootstrap-mfx-table1
#| echo: false
#| results: asis
#| tbl-cap: "ブートストラップ法による推定結果"
summary_boot |> 
  mutate(across(where(is.numeric), .fns = \(x) formattable::comma(x, digits = 4))) |> 
  mutate(
    # texreg::screenreg() っぽいフォーマットに変換
    info = str_glue("{estimate}{gtools::stars.pval(p.value)}<br>({std.error})"),
    # 推定値とp-値の両方がほぼゼロ → 使用されていない変数のため空白にする
    info = if_else(near(estimate, 0) & near(p.value, 0), " ", info)
  ) |> 
  pivot_wider(id_cols = term, names_from = type, values_from = info) |> 
  kableExtra::kbl(escape = F) |> 
  kableExtra::kable_styling(full_width = F) |> 
  kableExtra::footnote(
    general = c(
      "括弧内はブートストラップ法による標準誤差",
      "Signif. codes:  0 ‘\\***’ 0.001 ‘\\**’ 0.01 ‘\\*’ 0.05 ‘.’ 0.1 ‘ ’ 1"
      )
  )  |> cat()
```
:::


