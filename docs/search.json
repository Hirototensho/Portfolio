[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Science Portfolio",
    "section": "",
    "text": "Readme",
    "crumbs": [
      "Readme"
    ]
  },
  {
    "objectID": "index.html#概要",
    "href": "index.html#概要",
    "title": "Data Science Portfolio",
    "section": "概要",
    "text": "概要\n　このポートフォリオは、筆者が過去に取り組んできた研究プロジェクトや、学んできたデータサイエンス手法について公開用にまとめたものです。\n\n専門分野：実証分析・因果推論・計量経済学・R/Pythonによる実装",
    "crumbs": [
      "Readme"
    ]
  },
  {
    "objectID": "index.html#目次",
    "href": "index.html#目次",
    "title": "Data Science Portfolio",
    "section": "目次",
    "text": "目次\n\n1  プロジェクト1：コロナ禍が若年層の雇用に与えた影響\n2  タイプIIトービットモデル",
    "crumbs": [
      "Readme"
    ]
  },
  {
    "objectID": "01-covid-19-labor-market.html",
    "href": "01-covid-19-labor-market.html",
    "title": "1  プロジェクト1：コロナ禍が若年層の雇用に与えた影響",
    "section": "",
    "text": "1.1 背景と目的\n2019年末に始まったコロナ禍は、企業が休業やリモートワークへの切り替えを余儀なくされるなど、雇用環境に大きな影響を与えました。特に新卒者の就職市場では、小売、レジャー、空運など外出制限の影響を受けやすい業界・業種で、採用計画の削減や採用中止が相次ぎました。\n　本研究では、コロナ禍以降に卒業した世代が賃金・就業・雇用形態の面で不利だったかを、明らかにすることを目的として、全国就業実態パネル調査（JPSED）で定量的評価を行いました。",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>プロジェクト1：コロナ禍が若年層の雇用に与えた影響</span>"
    ]
  },
  {
    "objectID": "01-covid-19-labor-market.html#使用データと手法",
    "href": "01-covid-19-labor-market.html#使用データと手法",
    "title": "1  プロジェクト1：コロナ禍が若年層の雇用に与えた影響",
    "section": "1.2 使用データと手法",
    "text": "1.2 使用データと手法\n　使用したデータは次のとおりです。\n\nデータ：国就業実態パネル調査（JPSED）の個票データのうち、2017年から2022年調査までの6年分を使用。\n2012年以降卒・35歳未満を分析対象とした（n=32,714）。\n\n分析に当たって3つのリサーチクエスチョンを設定し、それぞれ次のような分析手法を採用しました。\n\nRQ1（賃金への影響）: コロナ禍以降に就職した世代は、それ以前の世代と比べて賃金が低下したか。\n\n分析手法として、タイプIIトービットモデルを使用しました1。\n\nRQ2（就業状態への影響）: コロナ禍以降に就職した世代は、それ以前の世代と比べて就業率が低下したか。\n\n分析手法として、多項ロジットモデルを使用しました。\n\nRQ3（非正規雇用率への影響）: コロナ禍以降に就職した世代は、それ以前の世代と比べて非正規雇用率が上昇したか。\n\n分析手法として、プロビットモデルを使用しました。\n\n\nまた、回答者を卒業年にしたがって「2018年以前」「2019年（基準）」「2020年」「2021年」という4つのコホートに分けることで、コロナ禍以降に卒業した世代が雇用面で不利だったかを明らかにすることを目指しました。",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>プロジェクト1：コロナ禍が若年層の雇用に与えた影響</span>"
    ]
  },
  {
    "objectID": "01-covid-19-labor-market.html#分析結果のポイント",
    "href": "01-covid-19-labor-market.html#分析結果のポイント",
    "title": "1  プロジェクト1：コロナ禍が若年層の雇用に与えた影響",
    "section": "1.3 分析結果のポイント",
    "text": "1.3 分析結果のポイント\n　本研究では、2020年以降の学卒者の賃⾦は19年卒者と⽐べて有意に低下したとの結果が得られました。加えて、19年卒⼥性と⽐べて21年卒⼥性の⾮正規雇⽤率が有意に増加している事が分りました。新卒⼥性における⾮正規雇⽤率の増加は、就職氷河期の初期にも⾒られた現象であり、影響の⻑期化が懸念される結果でした。一方で、就業率に有意な変化は確認されず、短期的な就業意欲は大きく崩れていないと考えられます。",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>プロジェクト1：コロナ禍が若年層の雇用に与えた影響</span>"
    ]
  },
  {
    "objectID": "01-covid-19-labor-market.html#考察",
    "href": "01-covid-19-labor-market.html#考察",
    "title": "1  プロジェクト1：コロナ禍が若年層の雇用に与えた影響",
    "section": "1.4 考察",
    "text": "1.4 考察\n　本研究の結果は、コロナ禍以降に卒業した世代が賃金と雇用形態の面で不利を抱えていることを示唆するものであった。太田ほか(太田 et al., 2007)など、就職氷河期をめぐる先行研究で指摘されている初職効果の存在を踏まえると、影響の固定化を避けるための対策が必要になると考えられます。\n　一方、本研究の限界としては2022年調査分までのデータを利用していることが挙げられます。2022年卒以降コホートの追跡、長期の影響を分析することが今後の課題と言えます。また、2023年以降は新卒初任給の上昇傾向が見られるため、最新の調査を用いた分析では異なる結果が得られるのではないかと考えられます2。\n\n\n\n\n太田聰一, 玄田有史, and 近藤絢子. (2007). 「溶けない氷河―世代効果の展望：時代を背負う労働者」. 『日本労働研究雑誌』, 568, 97–112.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>プロジェクト1：コロナ禍が若年層の雇用に与えた影響</span>"
    ]
  },
  {
    "objectID": "01-covid-19-labor-market.html#footnotes",
    "href": "01-covid-19-labor-market.html#footnotes",
    "title": "1  プロジェクト1：コロナ禍が若年層の雇用に与えた影響",
    "section": "",
    "text": "タイプIIトービットモデルについては Chapter 2 を参照してください。↩︎\n例えば「独立行政法人 労働政策研究・研修機構：新規学卒者の賃金」を参照。↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>プロジェクト1：コロナ禍が若年層の雇用に与えた影響</span>"
    ]
  },
  {
    "objectID": "02-typeII-tobit.html",
    "href": "02-typeII-tobit.html",
    "title": "2  タイプIIトービットモデル",
    "section": "",
    "text": "2.1 要約",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>タイプIIトービットモデル</span>"
    ]
  },
  {
    "objectID": "02-typeII-tobit.html#要約",
    "href": "02-typeII-tobit.html#要約",
    "title": "2  タイプIIトービットモデル",
    "section": "",
    "text": "賃金やECサイトでの購買金額のように、特定の回答者（e.g. 働いている人, ECサイトの利用者）しか観測できないデータを被説明変数とする場合に使える手法です\n被説明変数を観測できている人だけを対象として分析を行うと、セレクションバイアスが生じます\nタイプIIトービットモデルを用いることで、セレクションバイアスを避けながら分析を行うことができます",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>タイプIIトービットモデル</span>"
    ]
  },
  {
    "objectID": "02-typeII-tobit.html#タイプiiトービットモデルの概要",
    "href": "02-typeII-tobit.html#タイプiiトービットモデルの概要",
    "title": "2  タイプIIトービットモデル",
    "section": "2.2 タイプIIトービットモデルの概要",
    "text": "2.2 タイプIIトービットモデルの概要\n　個人 \\(i\\) の賃金を \\(W_i\\) として \\(\\log W_i = \\boldsymbol{X}_i^\\mathsf{T}\\boldsymbol{\\beta} + \\epsilon_{2i}\\) で定まる回帰モデルを推定する問題を考えます。これは労働経済学ではミンサー型賃金関数と呼ばれ、年齢と所得の関係を調べる賃金プロファイルや、教育年数が所得に与える効果を調べるために用いられます(大森 & 永瀬, 2021; 川口, 2017)。賃金関数の推定に当たっては、賃金 \\(W_i\\) が就業者についてしか観測することができないことが問題となります（図 2.1）。\n　このような状況は、就労状況に関する社会調査で頻繁に見られます。例えばリクルートワークス研究所が実施している「全国就業実態パネル調査」でも、今現在働いている回答者は仕事からの年収について質問される一方で、今現在働いていない回答者は質問されない（設問の対象から外れる）ことになっています。\n\n\n\n\n\n\n\n\n図 2.1: 一部の回答者の賃金が観測できない状況\n\n\n\n\n\n　働いていない回答者からすれば、仕事からの年収について質問されても答えようがないので、欠測値になるのは仕方のないことです。しかし、通常の回帰分析は被説明変数に欠測値がないことが前提になっているので、何かしらの対処が必要になります。\n　欠測値に対する簡単な対処法として、賃金 \\(W_i\\) が観測されているデータだけを使って分析すること（完全ケース解析）が考えられますが、就業者と非就業者の属性に系統的な違い（例：女性や高齢者の非就業率が高い）があるなら、推定結果にバイアス（選択バイアス）が生じる可能性があります。また、非就業者について欠測値を0で埋めること（定数代入）も適切ではありません。なぜなら、現在働いていない人でも働けば一定額の賃金が得られるはずだからです(末石, 2015, pp. 111–113)。\n　このような課題に対して、完全ケース解析や定数代入を避けて分析を実施する方法の1つがタイプIIトービットモデルです。タイプIIトービットモデルでは、賃金が観測されるかどうか（≒ その回答者が働いているかどうか）を予測するプロビットモデルと、賃金を予測する線形モデルを組み合わせることで、選択バイアスを補正します(図 2.2)。タイプIIトービットモデルの推定方法としては、Heckman の2段階推定と最尤法が知られていますが、どちらもsampleSelection パッケージの heckit() 関数として実装されています。\n\n\n\n\n\n\n\n\n図 2.2: タイプIIトービットモデルの模式図",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>タイプIIトービットモデル</span>"
    ]
  },
  {
    "objectID": "02-typeII-tobit.html#heckman-の2段階推定",
    "href": "02-typeII-tobit.html#heckman-の2段階推定",
    "title": "2  タイプIIトービットモデル",
    "section": "2.3 Heckman の2段階推定",
    "text": "2.3 Heckman の2段階推定\n　ここではタイプIIトービットモデルの推定法のうち、より簡単な Heckman の2段階推定について説明します。Heckman の2段階推定は、(1) 賃金 \\(W_i\\) が観測されるかどうかを予測するプロビットモデル（就業決定関数）、(2) 賃金を予測する線形モデル（賃金関数）を、次のような手順で組み合わせます。\n　まず、賃金が観測されていれば1、観測されていなければ0となるダミー変数 \\(D_i\\) を被説明変数として使い、 \\(\\boldsymbol{Z}_i\\) を説明変数とする、次のプロビットモデルを推定します。\n\\[\n\\large\n\\begin{equation}\n\\begin{aligned}\n\\Phi(D_i) &= \\boldsymbol{Z}_i^\\mathsf{T}\\boldsymbol{\\gamma} + \\epsilon_{1i}\n\\end{aligned}\n\\end{equation}\n\\tag{2.1}\\]\n次に、推定されたプロビットモデルから \\(\\lambda(\\boldsymbol{Z}_i^\\mathsf{T} \\boldsymbol{\\gamma}) = \\phi(\\boldsymbol{Z}_i^\\mathsf{T}\\boldsymbol{\\gamma}) / \\Phi(\\boldsymbol{Z}_i^\\mathsf{T}\\boldsymbol{\\gamma})\\) として定義される逆ミルズ比を推定します。最後に、逆ミルズ比を説明変数に加えた次のモデルを最小二乗法で推定することで、セレクションバイアスが補正された回帰係数 \\(\\boldsymbol{\\beta}\\) の推定値を得ることができます。\n\\[\n\\large\n\\begin{equation}\n\\begin{aligned}\n\\log W_i &= \\boldsymbol{X}_i^\\mathsf{T}\\boldsymbol{\\beta}\n+ \\sigma_{12}\\lambda(\\boldsymbol{Z}_i^\\mathsf{T} \\boldsymbol{\\gamma})\n+ \\epsilon_{2i}\n\\end{aligned}\n\\end{equation}\n\\tag{2.2}\\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>タイプIIトービットモデル</span>"
    ]
  },
  {
    "objectID": "02-typeII-tobit.html#使用上の注意点",
    "href": "02-typeII-tobit.html#使用上の注意点",
    "title": "2  タイプIIトービットモデル",
    "section": "2.4 使用上の注意点",
    "text": "2.4 使用上の注意点\nタイプIIトービットモデルの使用にあたり、次の2点に注意が必要です。\n\nプロビットモデルの説明変数 \\(\\boldsymbol{Z}_i\\) には、線形モデルの説明変数 \\(\\boldsymbol{X}_i\\) に含まれていない変数を、少なくとも追加する必要がある\n\n具体的には、線形モデルの説明変数 \\(\\boldsymbol{X}_i\\) には教育年数と年齢を使い、プロビットモデルの説明変数 \\(\\boldsymbol{Z}_i\\) には教育年数と年齢に加えて子どもの人数を使う、といった配慮が必要です。\n\n説明変数 \\(\\boldsymbol{Z}_i, \\boldsymbol{X}_i\\) の欠測値には、タイプIIトービットモデルだけでは対応できない\n\n職場の業種や現職の勤続年数、職種、肩書など、賃金以外にも非就業者については観測できない変数は数多くあります。しかし、タイプIIトービットモデルで対応できるのは被説明変数の欠測だけなので、就業者と非就業者の両方で観測できる説明変数だけを使うか、他の方法で補完するといった対応が必要です",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>タイプIIトービットモデル</span>"
    ]
  },
  {
    "objectID": "02-typeII-tobit.html#rによる実装",
    "href": "02-typeII-tobit.html#rによる実装",
    "title": "2  タイプIIトービットモデル",
    "section": "2.5 Rによる実装",
    "text": "2.5 Rによる実装\n\nExample 2.1 (Heckman の2段階推定法) ここでは sampleSelection パッケージの Mroz87データを例に、sampleSelection::heckit() 関数を使って Heckman の2段階推定法を実装します。Mroz87 データは1975年に実施された Panel Study of Income Dynamics をもとにしたデータです。753名の既婚女性のデータが記録されており、内428名が就業者、残る325名が非就業者です。Mroz87 には就業状態 lfp や賃金wage、教育年数educや労働市場経験年数exper、配偶者の賃金huswage` が収録されており、今回はこれに Heckman の2段階推定を組み合わせて賃金関数を推定します。\n　まずはサンプルデータを読み込みます。\ndata(\"Mroz87\", package = \"sampleSelection\")\nMroz87 |&gt; dim()\n#&gt; [1] 753  22\nMroz87 データでは非就業者の賃金は全て0（wage = 0）として記録されているのですが、ここでは処理を明確にするために非就業者の賃金は欠測値 NA に置き換え、さらに対数賃金を計算しておきます。\nMroz87 &lt;- Mroz87 |&gt; \n  naniar::replace_with_na(replace = list(wage = 0)) |&gt; \n  mutate(lwage = log(wage)) \n\n# 労働参加 lfp = 0 の回答者は全て lwage が観測されています。\nMroz87 |&gt; mutate(miss_lwage = is.na(lwage)) |&gt; \n  janitor::tabyl(lfp, miss_lwage)\n#&gt;  inlf FALSE TRUE\n#&gt;     0     0  325\n#&gt;     1   428    0\n次に sampleSelection::heckit() 関数でタイプIIトービットモデルを推定します。heckit() 関数を使うときは、selection 引数に就業決定関数の回帰式を指定し、outcome 引数に賃金関数の回帰式を指定します。今回は、典型的なミンサー型賃金関数で使われる教育年数 educ と経験年数 exper およびその2乗項に加えて配偶者の賃金 huswage を説明変数として使い、就業決定関数では、賃金関数の説明変数に加えて年齢 age と子どもの人数（kids5 および kids618）を説明変数として使用します。また、ここでは Heckman の2段階推定を使うので method = \"2step\" を指定します。\nfit_heckit &lt;- sampleSelection::heckit(\n  selection = lfp ~ educ + exper + I(exper^2) + huswage + age + kids5 + kids618, # 就業決定関数\n  outcome = lwage ~ educ + exper + I(exper^2) + huswage,                         # 賃金関数\n  data = Mroz87,\n  method = \"2step\"\n)\nsummary(fit_heckit)\n#&gt; --------------------------------------------\n#&gt; Tobit 2 model (sample selection model)\n#&gt; 2-step Heckman / heckit estimation\n#&gt; 753 observations (325 censored and 428 observed)\n#&gt; 16 free parameters (df = 738)\n#&gt; Probit selection equation:\n#&gt;               Estimate Std. Error t value Pr(&gt;|t|)    \n#&gt; (Intercept)  0.3606478  0.5057097   0.713   0.4760    \n#&gt; educ         0.1248354  0.0248294   5.028 6.24e-07 ***\n#&gt; exper        0.1260740  0.0186842   6.748 3.04e-11 ***\n#&gt; I(exper^2)  -0.0019245  0.0006001  -3.207   0.0014 ** \n#&gt; huswage     -0.0255439  0.0126406  -2.021   0.0437 *  \n#&gt; age         -0.0547300  0.0084083  -6.509 1.40e-10 ***\n#&gt; kids5       -0.8650260  0.1180205  -7.329 6.08e-13 ***\n#&gt; kids618      0.0285095  0.0434365   0.656   0.5118    \n#&gt; Outcome equation:\n#&gt;               Estimate Std. Error t value Pr(&gt;|t|)    \n#&gt; (Intercept) -0.4472713  0.3122183  -1.433   0.1524    \n#&gt; educ         0.0955365  0.0168361   5.675    2e-08 ***\n#&gt; exper        0.0370433  0.0166119   2.230   0.0261 *  \n#&gt; I(exper^2)  -0.0006878  0.0004465  -1.540   0.1239    \n#&gt; huswage      0.0192415  0.0098639   1.951   0.0515 .  \n#&gt; Multiple R-Squared:0.1643,   Adjusted R-Squared:0.1544\n#&gt;    Error terms:\n#&gt;               Estimate Std. Error t value Pr(&gt;|t|)\n#&gt; invMillsRatio -0.06114    0.14170  -0.431    0.666\n#&gt; sigma          0.66171         NA      NA       NA\n#&gt; rho           -0.09240         NA      NA       NA\n#&gt; --------------------------------------------\n　推定結果は Probit selection equation が就業決定関数の結果を、Outcome equation が賃金関数の結果を表しています。今回の推定結果を見ると、妻の教育年数 educ と経験年数 exper が伸びるほど就業率と賃金が高くなり、配偶者の賃金 huswage が高くなるほど妻の就業率は低下するものの、賃金には影響を与えないことが読み取れます1。\n　ちなみに、sampleSelection::heckit(method = \"2step\") の結果に broom::tidy() を使うときは broom::tidy(fit_heckit$lm) で賃金関数の推定値を、broom::tidy(fit_heckit$probit) で就業決定関数の推定値を表示できるほか、texreg::screenreg() 関数にも対応しています。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>タイプIIトービットモデル</span>"
    ]
  },
  {
    "objectID": "02-typeII-tobit.html#タイプiiトービットモデルの限界効果",
    "href": "02-typeII-tobit.html#タイプiiトービットモデルの限界効果",
    "title": "2  タイプIIトービットモデル",
    "section": "2.6 タイプIIトービットモデルの限界効果",
    "text": "2.6 タイプIIトービットモデルの限界効果\n　計量経済学の実証論文では、ロジスティック回帰やプロビットモデルの推定結果を限界効果（marginal effect）に変換してから掲載することがよく行われます。限界効果とは、ある説明変数 \\(\\boldsymbol{x}_j\\) が僅かに変化したときに、被説明変数や予測確率がどの程度増減するかを表すもので、回帰式を説明変数 \\(\\boldsymbol{x}_{ij}\\) で偏微分したものとして定義されます。\n　タイプIIトービットモデルについても、次式によって限界効果を計算できることが知られています(Hoffmann & Kassouf, 2005; ダハナ & 勝又, 2023, pp. 139–140)。\n\\[\n\\large\n\\begin{equation}\n\\begin{aligned}\nME(x_{ij}) &= \\frac{\\partial}{\\partial x_{i, j}}\\log E[W_i]\n= \\underbrace{\n\\beta_j - \\gamma_j \\sigma_{12} \\delta_i}_{e_I}\n+ \\underbrace{\n\\gamma_j \\lambda(\\boldsymbol{Z}_i^\\mathsf{T}\\boldsymbol{\\gamma})\n}_{e_{II}}\\\\\n\\delta_i &= \\lambda(\\boldsymbol{Z}_i^\\mathsf{T}\\boldsymbol{\\gamma})\n[\\boldsymbol{Z}_i^\\mathsf{T}\\boldsymbol{\\gamma}\n+ \\lambda(\\boldsymbol{Z}_i^\\mathsf{T}\\boldsymbol{\\gamma})]\n\\end{aligned}\n\\end{equation}\n\\tag{2.3}\\]\n式 2.3 の限界効果には、条件付き限界効果 \\(e_I\\)、間接効果 \\(e_{II}\\)、条件なしの限界効果 \\(ME(x_{ij})\\) の3通りに分解できるという特徴があり、それぞれの項には次のような意味があります(Hoffmann & Kassouf, 2005)。\n\n\\(e_I\\) 条件付き限界効果（conditional marginal effect）： 説明変数 \\(\\boldsymbol{x}_j\\) の変化が就業者の賃金に与える効果を表す\n\\(e_{II}\\) 間接効果：説明変数 \\(\\boldsymbol{x}_j\\) の変化が、就業率の変化を通じて間接的に賃金を変化させる効果\n\\(ME(x_{ij})\\) 条件なしの限界効果（unconditional marginal effect）：説明変数 \\(\\boldsymbol{x}_j\\) の変化が就業者と非就業者の全体の賃金に与える効果を表す\n\n　例えば Hoffmann, Kassouf(2005, p. 12)は、実証分析に 式 2.3 の分解を利用することで、ブラジルの女性の教育年数が1年伸びることが、勤労女性の収入を11.6%上昇させると同時に、女性の労働市場参加率を5.2%増加させることで、女性全体の所得を17.4％増加させる効果を持つと報告しています。　　 　このように、教育年数が収入に与える効果をより豊かな洞察をもたらす形で提示できることは、タイプIIトービットモデルを用いる利点の1つだと言えるでしょう。\n\nExample 2.2 (タイプIIトービットモデルの限界効果) ここではタイプIIトービットモデルの限界効果をRで実装します。ダハナ, 勝又(2023, pp. 139–140)と Hoffmann, Kassouf(2005)、そして heckitmfxパッケージの heckitmfx::heckitmfx_log() 関数の実装を参考に、式 2.3 の限界効果をRの関数として実装します。\n\n\n\nheckitmfx.R\n\n# メインの関数から呼び出されて、限界効果を推定する関数 ------------------------------------------------------------\nheckitmfx_compute &lt;- function(\n    gamma, beta, betalambda, Z, ...\n    # type = c(\"unconditional\", \"conditional\", \"selection\")\n){\n  # 就業決定関数の予測値と逆ミルズ比の計算 ---------------------------------\n  alpha &lt;- Z %*% gamma\n  lambda &lt;- dnorm(alpha) / pnorm(alpha)\n  delta &lt;- lambda * (lambda + alpha)\n  \n  # 限界効果の各項の計算 ---------------------\n  selection &lt;- gamma[-1] * mean(lambda)\n  ei_2 &lt;- gamma[-1] * betalambda * mean(delta)\n  \n  # ダミー変数用の処理 --------------\n  dummy_vars &lt;- apply(Z[, -1], FUN = is_dummy, MARGIN = 2)\n  \n  if(sum(dummy_vars) &gt;= 1){\n    terms_for_dummy_vars &lt;- names(dummy_vars[dummy_vars]) |&gt;\n      terms_for_dummy(Z, gamma, betalambda)\n    \n    # ダミー変数についての推定値に置換\n    ei_2[dummy_vars] &lt;- terms_for_dummy_vars[1, ]\n    selection[dummy_vars] &lt;- terms_for_dummy_vars[2, ]\n  }\n  \n  # 回帰係数と限界効果の各項をデータフレームにまとめます。\n  est &lt;- merge(\n    data.frame(beta = beta[-1]), \n    data.frame(gamma = gamma[-1]), \n    by = \"row.names\", all = TRUE\n    ) |&gt; \n    rename(term = \"Row.names\") |&gt; \n    full_join(tibble::tibble(ei_2, term = names(ei_2)), by = join_by(term)) |&gt; \n    full_join(tibble::tibble(selection, term = names(selection)), by = join_by(term))\n  \n  est[is.na(est)] &lt;- 0\n  \n  # 限界効果の推定\n  res &lt;- est |&gt; \n    mutate(\n      term = as.character(term),\n      conditional = beta - ei_2,\n      unconditional = conditional + selection\n    ) |&gt; \n    select(term, unconditional, conditional, selection, beta, gamma)\n  # 結果の出力 ---------------------------------\n  \n  return(res)\n}\n\n\n次に、Hoffmann, Kassouf(2005)に基づいて説明変数 \\(\\boldsymbol{x}_j\\) がダミー変数である場合の処理を実装します。\n\n\n\nheckitmfx.R\n\n# ダミー変数を判定する関数\nis_dummy &lt;- function(x, unique_value = c(0, 1), na.rm = FALSE) {\n  if(na.rm) x &lt;- na.omit(x)\n  res &lt;- checkmate::test_set_equal(x = x, y = unique_value)\n  return(res)\n}\n\n# ダミー変数に関する間接効果の計算\nterms_for_dummy &lt;- Vectorize(function(var_name, Z, gamma, betalambda){\n  fun_inv_mills &lt;- \\(x) dnorm(x) / pnorm(x)\n  \n  z_1 &lt;- z_0 &lt;- colMeans(Z)\n  z_1[var_name] &lt;- 1\n  z_0[var_name] &lt;- 0\n  \n  delta_lambda &lt;- betalambda * as.vector(fun_inv_mills(z_1 %*% gamma) - fun_inv_mills(z_0 %*% gamma))\n  delta_log_phi &lt;- as.vector(pnorm(z_1 %*% gamma, log.p = TRUE) - pnorm(z_0 %*% gamma, log.p = TRUE))\n  \n  res &lt;- rbind(delta_lambda, delta_log_phi) \n  return(res)\n}, vectorize.args = \"var_name\")\n\n\n最後に、限界効果を推定するメインの関数である heckitmfx() 関数を実装します。\n\n\n\nheckitmfx.R\n\n# モデルオブジェクトから限界効果を推定するメインの関数 ------------------------------------------------------------\nheckitmfx &lt;- function(model, newdata = NULL, .params = NULL, ...){\n  # 回帰係数の抽出 ---------------------------------\n  if(is.null(.params)){\n    coef_all &lt;- coef(model) # 全ての回帰係数を取得  \n  }else{\n    # デルタ法の実装に使うための、回帰係数を任意の値で上書きする機能\n    coef_all &lt;- .params # 引数 .params が指定されていた場合は .params で上書きする\n  }\n  \n  # 全ての説明変数の名前を抽出\n  all_vars &lt;- names(coef_all) |&gt; unique() %&gt;% \n    subset(!(. %in% c(\"(Intercept)\", \"invMillsRatio\", \"sigma\", \"rho\")))\n  \n  # 賃金関数の回帰係数が始まる位置を特定する\n  start_beta &lt;- which(names(coef_all) == \"(Intercept)\")[2]\n  \n  gamma &lt;- coef_all[1:(start_beta - 1)] # 就業決定関数の回帰係数\n  \n  # 賃金関数の回帰係数\n  beta &lt;- coef_all[start_beta:length(coef_all)] %&gt;%\n    subset(!(names(.) %in% c(\"invMillsRatio\", \"sigma\", \"rho\")))\n  \n  betalambda &lt;- coef_all %&gt;% subset((names(.) %in% c(\"sigma\", \"rho\"))) |&gt; prod()\n  \n  # 就業決定関数の計画行列の抽出 ---------------------------------\n  if(model$method == \"2step\"){\n    Z &lt;- model.matrix(model$probit, data = newdata)\n    colnames(Z) &lt;- str_remove(colnames(Z), \"XS\")\n  }else{\n    if(model$method == \"ml\"){\n      Z &lt;- model.matrix(model$termsS, data = newdata)\n    }\n  }\n  # 限界効果の推定\n  res &lt;- heckitmfx_compute(\n    gamma = gamma,\n    beta = beta,\n    betalambda = betalambda,\n    Z = Z\n  )\n  return(res)\n}\n\n\n　例題 2.1 で推定したモデル（fit_heckit）に対して heckitmfx() を実行すると、次のような結果が得られます。\nheckitmfx(fit_heckit) |&gt; \n  mutate(across(where(is.numeric), .fns = \\(x) round(x, 5)))\n#&gt;         term unconditional conditional selection     beta    gamma\n#&gt; 1        age      -0.04270    -0.00187  -0.04083  0.00000 -0.05473\n#&gt; 2       educ       0.19293     0.09981   0.09313  0.09554  0.12484\n#&gt; 3      exper       0.13541     0.04136   0.09405  0.03704  0.12607\n#&gt; 4    huswage      -0.00069     0.01837  -0.01906  0.01924 -0.02554\n#&gt; 5 I(exper^2)      -0.00219    -0.00075  -0.00144 -0.00069 -0.00192\n#&gt; 6      kids5      -0.67489    -0.02959  -0.64531  0.00000 -0.86503\n#&gt; 7    kids618       0.02224     0.00098   0.02127  0.00000  0.02851\nなお、heckitmfx() 関数の出力の各列は次の値に対応しています。\n\nunconditional： 条件なしの平均限界効果 \\(\\overline{ME}(\\boldsymbol{x}_j)\\)。\nconditional： 条件付き平均限界効果 \\(\\overline{ME}(\\boldsymbol{x}_j | Y_{1i}^* \\ge 0)\\)。\nselection： 間接効果の平均値 \\(e_{II} = \\gamma_j \\lambda(\\boldsymbol{Z}_i^\\mathsf{T}\\boldsymbol{\\gamma})\\)\nbeta：賃金関数の回帰係数の推定値 \\(\\hat{\\boldsymbol{\\beta}}\\)\ngamma：就業決定関数の回帰係数の推定値 \\(\\hat{\\boldsymbol{\\gamma}}\\)\n\n\n\nExample 2.3 (ブートストラップ法を使った限界効果の標準誤差の推定) ここでは 例題 2.2 で推定したタイプIIトービットモデルの限界効果について、ブートストラップ法を使った標準誤差の推定と検定を試みたいと思います。まず、 例題 2.1 で実装したモデル推定し、例題 2.2 で実装した heckitmfx() 関数で限界効果を推定するまでの操作を、ひとまとめにしたラッパー関数を定義します。\n\nest_heckit_mfx &lt;- function(data){\n  mod &lt;- sampleSelection::heckit(\n    selection = lfp ~ educ + exper + I(exper^2) + huswage + age + kids5 + kids618, # 就業決定関数\n    outcome = lwage ~ educ + exper + I(exper^2) + huswage,                         # 賃金関数\n    data = data,\n    method = \"2step\"\n  )\n  res &lt;- heckitmfx(mod, newdata = data)  \n  return(res)\n}\n\n次に、slice_sample() 関数で復元抽出を行い、反復回数を1,000回でブートストラップ法を実行します。\nset.seed(123)\ntictoc::tic() # 参考までに実行時間を計測しておきます。\n\nheckitmfx_with_boot &lt;- map(\n  .x = 1:1000, \n  .f = \\(x) est_heckit_mfx(Mroz87 |&gt; slice_sample(prop = 1, replace = TRUE))\n  ) |&gt;\n  bind_rows(.id = \"Iteration\")\n\ntictoc::toc()\n#&gt; 15.565 sec elapsed\nここでは ggdist::stat_pointinterval() 関数を使ってブートストラップ統計量の分布を可視化してみましょう。\n\nheckitmfx_with_boot |&gt; \n  select(Iteration:selection) |&gt; \n  pivot_longer(unconditional:selection, names_to = \"type\", values_to = \"estimate\") |&gt; \n  ggplot(aes(x = estimate, y = term)) +\n  geom_vline(xintercept = 0, color = \"gray60\", linetype = 2) +\n  ggdist::stat_pointinterval(\n    color = my_color, alpha = 0.7, \n    point_interval = \"mean_qi\", # `summarise_boot` と一致するように点推定を平均値とします。\n    .width = c(0.95, 0.99)\n    ) + \n  facet_wrap(~type)\n\n\n\n\n\n\n\n\n次に、heckitmfx() で得られる3種類の限界効果について、ブートストラップ統計量を集計して、それぞれ標準誤差分位点法による\\(p\\)-値を計算します。なお、ブートストラップ法やブートストラップ法での信頼区間と\\(p\\)-値の計算方法については末石(2015, p. 140)、Efron & Hastie(2016)、Taddy(2019)および Bodory et al.(Bodory et al., 2020, p. 16)を参照してください。\n\nsummarise_boot &lt;- function(res_boot, var){\n  res_boot |&gt; \n    summarise(\n    type = var,\n    estimate = mean(.data[[var]]),\n    std.error = sd(.data[[var]]),                                        # 標準誤差\n    p.value = 2 * pmin(mean(.data[[var]] &lt;= 0), mean(.data[[var]] &gt; 0)), # 分位点法によるp-値\n    .lower = quantile(.data[[var]], 0.025),\n    .upper = quantile(.data[[var]], 0.975),\n    .by = term\n  )\n}\n\nsummary_boot &lt;- map(\n  .x = c(\"unconditional\", \"conditional\", \"selection\"), \n  .f = \\(x) summarise_boot(heckitmfx_with_boot, x)\n  ) |&gt; \n  bind_rows()\n\n　最後に推定結果を比較しやすいように、texreg::screenreg() を模したフォーマットに変換してみましょう。推定結果を比較すると、年齢 Age や Crossbuying などように一貫して限界効果が統計的に有意な変数がある一方で、性別 Sex については総効果 dydx では有意でなくても間接効果は有意であるという結果になっていることが興味深く感じられます（表 2.1）。\n\n\n\n表 2.1: ブートストラップ法による推定結果\n\n\n\n\n\n\nterm\n\n\nunconditional\n\n\nconditional\n\n\nselection\n\n\n\n\n\n\nage\n\n\n-0.0433***(0.0091)\n\n\n-0.0017 (0.0055)\n\n\n-0.0416***(0.0068)\n\n\n\n\neduc\n\n\n0.1941***(0.0244)\n\n\n0.0993***(0.0140)\n\n\n0.0948***(0.0196)\n\n\n\n\nexper\n\n\n0.1364***(0.0214)\n\n\n0.0414**(0.0151)\n\n\n0.0951***(0.0158)\n\n\n\n\nhuswage\n\n\n-0.0011 (0.0138)\n\n\n0.0182.(0.0103)\n\n\n-0.0193.(0.0099)\n\n\n\n\nI(exper^2)\n\n\n-0.0022***(0.0006)\n\n\n-0.0008*(0.0004)\n\n\n-0.0014**(0.0005)\n\n\n\n\nkids5\n\n\n-0.6802***(0.1307)\n\n\n-0.0259 (0.0863)\n\n\n-0.6543***(0.0985)\n\n\n\n\nkids618\n\n\n0.0233 (0.0357)\n\n\n0.0008 (0.0053)\n\n\n0.0225 (0.0341)\n\n\n\n\n\n\nNote: \n\n\n\n\n 括弧内はブートストラップ法による標準誤差\n\n\n\n\n Signif. codes: 0 ’***’ 0.001 ’**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1\n\n\n\n\n\n\n\n\n\n\n\n\nBodory, Hugo, Lorenzo Camponovo, Martin Huber, and Michael Lechner. (2020). The finite sample performance of inference methods for propensity score matching and weighting estimators. Journal of Business & Economic Statistics, 38(1), 183–200.\n\n\nEfron, Bradley, and Trevor Hastie. (2016). Computer age statistical inference. Cambridge University Press. https://web.stanford.edu/~hastie/CASI/ Institute of mathematical statistics monographs\n\n\nHoffmann, Rodolfo, and Ana Lucia Kassouf. (2005). Deriving conditional and unconditional marginal effects in log earnings equations estimated by heckman’s procedure. Applied Economics, 37(11), 1303–1311.\n\n\nTaddy, Matt. (2019). Business data science: Combining machine learning and economics to optimize, automate, and accelerate business decisions. McGraw-Hill Education. https://www.oreilly.com/library/view/business-data-science/9781260452785/ 上杉隼人, 井上毅郎〔訳〕(2020)『ビジネスデータサイエンスの教科書』すばる舎\n\n\nダハナ・ウィラワン ドニ, and 勝又壮太郎. (2023). 『Rによるマーケティング・データ分析: 基礎から応用まで (ライブラリ データ分析への招待 4)』. 新世社.\n\n\n大森義明, and 永瀬伸子. (2021). 『労働経済学をつかむ』. 有斐閣.\n\n\n川口大司. (2017). 『労働経済学 – 理論と実証をつなぐ』. 有斐閣.\n\n\n春山鉄源. (2023). Pythonで学ぶ入門計量経済学. https://py4etrics.github.io/index.html\n\n\n末石直也. (2015). 『計量経済学：ミクロデータ分析へのいざない』. 日本評論社.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>タイプIIトービットモデル</span>"
    ]
  },
  {
    "objectID": "02-typeII-tobit.html#footnotes",
    "href": "02-typeII-tobit.html#footnotes",
    "title": "2  タイプIIトービットモデル",
    "section": "",
    "text": "分析結果の解釈方法については、春山(2023)なども参照してください。↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>タイプIIトービットモデル</span>"
    ]
  },
  {
    "objectID": "03-grouping-by-pulp.html",
    "href": "03-grouping-by-pulp.html",
    "title": "3  プロジェクト2：制約付き最適化によるグループ分け",
    "section": "",
    "text": "3.1 背景\n私が在籍している大学院で開講された講義において、グループワークを実施するに当たり、担当教員から約50名の受講生を5つの班に分けて、その結果を2日後までに報告するようにとの指示がありました。さらに、受講生の分け方について、先生から理由から次のような条件が課されていました（受講生の名前は全て仮名です）。\n上記の制約条件を全て満たしつつ、限られた時間で受講生を手作業で振り分けるのは困難だと考え、班分けを自動化することを考えました。具体的には、岩永ほか(2024)を参考に Python の PuLP ライブラリを用いて組合せ最適化問題として実装しました。\n　次節では、当時実装したコードをもとにした実装例を紹介します。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>プロジェクト2：制約付き最適化によるグループ分け</span>"
    ]
  },
  {
    "objectID": "03-grouping-by-pulp.html#背景",
    "href": "03-grouping-by-pulp.html#背景",
    "title": "3  プロジェクト2：制約付き最適化によるグループ分け",
    "section": "",
    "text": "A〜Eの全5班に分ける\n1班につき7名または8名\n各班に社会人経験のある学生が3名以上含まれる\n以下の学生は、特に優秀であるためばらばらの班とする\n\n松本, 山田, 山本, 前田, 井上\n\n各班に理系学生が1名以上2名以下含まれる",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>プロジェクト2：制約付き最適化によるグループ分け</span>"
    ]
  },
  {
    "objectID": "03-grouping-by-pulp.html#実装例",
    "href": "03-grouping-by-pulp.html#実装例",
    "title": "3  プロジェクト2：制約付き最適化によるグループ分け",
    "section": "3.2 実装例",
    "text": "3.2 実装例\n　本節では、Python の PuLP ライブラリを用いてグループワークの班分けを実装します。\n\n\nPyhon\n\n# ! pip install pulp\nimport numpy as np\nimport pandas as pd\nimport pulp # 線形計画法を解くためのライブラリ\n\nここでは班分けを行う学生の一覧は次のようなデータフレームとして与えられているとします。\n\n\nPyhon\n\njukousei_df = pd.read_excel('data/グループ分けサンプルデータ.xlsx')\n\nprint(jukousei_df.head())\n#&gt;    氏名  社会人経験あり     文系     理系\n#&gt; 0  佐藤         True       True     False\n#&gt; 1  鈴木         True      False      True\n#&gt; 2  高橋         True      False      True\n#&gt; 3  田中        False      False      True\n#&gt; 4  伊藤        False       True     False\n\nここで \\(x_{i, g}\\) を学生 \\(i\\) は班 \\(g\\) に参加していれば \\(x_{i, g} = 1\\)、そうでなければ \\(x_{i, g} = 0\\) となる変数であるとします。さらに \\(G\\) を班のリスト、\\(I\\) を学生のリストとし、\\(W\\) を社会人経験のある学生のリスト、\\(S\\) を優秀であると指名された学生のリスト、\\(R\\) を理系学生のリストであるとすると、前節の制約条件は次式のように表すことが出来ます。\n\\[\n\\large\n\\begin{equation}\n\\begin{aligned}\n\\text{s.t.}\n&\\sum_{g \\in G} x_{i, g} = 1,\n&&\\normalsize{i \\in I} &\\\\\n&\\sum_{i \\in I} x_{i, g} \\in [7, 8],\n&&\\normalsize{g \\in G} &\\\\\n&\\sum_{i \\in W} x_{i, g} \\ge 3\n&&\\normalsize{g \\in G} &\\\\\n&\\sum_{i \\in S} x_{i, g} \\le 1\n&&\\normalsize{g \\in G} &\\\\\n&\\sum_{i \\in R} x_{i, g} \\in [1, 2]\n&&\\normalsize{g \\in G} &\\\\\n\\end{aligned}\n\\end{equation}\n\\tag{3.1}\\]\n　式 3.1 について少し説明しておくと、1行目は全ての受講生 \\(i\\) がどれか1つの班に属することを意味し、班のリスト \\(G\\) が5つの要素をもつことで学生が5つの班に分けられることを意味しています。2行目の条件が全ての班が \\(g\\) が7〜8人の受講生で構成されることを意味し、3行目の条件がどの班 \\(g\\) にも社会人経験のある学生 \\(i \\in W\\) が3名以上いることを意味します。さらに 4行目の条件が指名された受講生 \\(i \\in S\\) は各班に1人以下しかいないことを意味するので、この制約を守るには全ての班にバラバラに振り分けることになります。最後に、5行目の条件が理系学生 \\(i \\in R\\) が各班につき1名以上2名以下となるように制約しています。\nPuLP ライブラリの導入と問題の定義 　 　まずは pulp ライブラリを使い、班分けの問題を組合せ最適化問題として定義していきましょう。\n\n\nPyhon\n\n# 問題の宣言\nproblem = pulp.LpProblem(\n    'GroupAssignmentProblem',\n    pulp.LpMaximize\n    )\n\n\n\nPyhon\n\n# 受講生のリスト\nnames_list = jukousei_df['氏名'].to_list()\n\n# A〜Eの全5班にわける\n# グループのリストを作成\ngroups = ['A', 'B', 'C', 'D', 'E']\nprint(len(groups))\n#&gt; 5\n\n# 参加者とグループのペアのリスト\nparticipant_group = [(i, g) for i in names_list for g in groups]\n\n# 参加者をどのクラスに割り当てるかを変数xとして定義する\n# 各参加者が各グループに属するか否かを 0 or 1 で最適化するので、Binaryを指定\nx = pulp.LpVariable.dicts('x', participant_group, cat = 'Binary')\n\n以下の処理は制約条件とは関係ありませんが、各班のメンバーが苗字の五十音順で偏よった結果として、「いつもと同じメンツ」という結果にならないように、実施しています。\n\n\nPyhon\n\n# 班の振り分けが名前順にならないように、並び順をランダム化する。\njukousei_df = jukousei_df.sample(frac = 1, random_state = 123)\n\n制約条件の設定\n　次に 式 3.1 の制約条件を Python のコードとして実装していきましょう。\n\n\nPyhon\n\n# 制約条件1' 各参加者は必ずどれか一つのグループに所属する\nfor i in names_list:\n    problem.addConstraint(\n        pulp.lpSum([x[i,g] for g in groups])==1\n        )\n\n\n\nPyhon\n\n# 制約条件2 1班につき7名または8名\nfor g in groups:\n    problem.addConstraint(\n        pulp.lpSum([x[i,g] for i in names_list]) &gt;= 7\n        )\n    problem.addConstraint(\n        pulp.lpSum([x[i,g] for i in names_list]) &lt;= 8\n        )\n\n\n\nPyhon\n\n# 制約条件3 各班に社会人（元も含む）が3名以上含まれる\n\n# 社会人である受講生のリスト\nshakaijin_list = jukousei_df.query('社会人経験あり')['氏名']\n\nfor g in groups:\n    problem.addConstraint(\n        pulp.lpSum([x[i,g] for i in shakaijin_list]) &gt;= 3\n        )\n\n\n\nPyhon\n\n# 4. 以下の学生は、特に優秀であるためばらばらの班とする\n#   - 松本, 山田, 山本, 前田, 井上\njukousei_df['指名学生'] = jukousei_df['氏名'].str.contains('松本|山田|山本|前田|井上')\n\n# 氏名された学生の名前をリストとして抽出\nselected_list = jukousei_df.query('指名学生')['氏名']\n\n# ここでは「指名された学生がばらばらの班になる」という条件を、\n# 「各グループに含まれる指名された学生の人数が1名以下になる」と翻訳しています。\nfor g in groups:\n    problem.addConstraint(\n        pulp.lpSum([x[i,g] for i in selected_list]) &lt;= 1\n        )\n\n\n\nPyhon\n\n# 制約条件5 各班に理系学生が1名、2名以上含まれる\nrikei_list = jukousei_df.query('理系')['氏名']\n\nfor g in groups:\n    problem.addConstraint(\n        pulp.lpSum([x[i,g] for i in rikei_list]) &gt;= 1\n        )\n    problem.addConstraint(\n        pulp.lpSum([x[i,g] for i in rikei_list]) &lt;= 2\n        )\n\n最適化問題を解く\n　次に、.solve() メソッドを使って最適化問題の解を求めます。\n\n\nPyhon\n\n# Python\nstatus = problem.solve()\n\n最適化問題の解を抽出し、結果をデータフレームの形に整形します。\n\n\nPyhon\n\n# Python\nresult_array = [[key[0],key[1]] for key in x.keys() if x[key].value()==1]\ndf_result = pd.DataFrame(result_array, columns = ['氏名','班番号'])\n\njukousei_df2 = jukousei_df.sort_index()\\\n  .merge(df_result, on = '氏名', how = 'left')\n\nprint(jukousei_df2.head())\n#&gt;    氏名  社会人経験あり     文系     理系   指名学生  班番号\n#&gt; 0  佐藤          True       True    False      False   D\n#&gt; 1  鈴木          True      False     True      False   A\n#&gt; 2  高橋          True      False     True      False   A\n#&gt; 3  田中         False      False     True      False   C\n#&gt; 4  伊藤         False       True    False      False   D\n\n制約条件を満たしているかどうかの確認\n　ここまでで班分けの結果が得られたので、指定された条件を満たしているかを確認しましょう。まずは所属する班を指定されていない学生の人数を調べます。0人であればOKです。\n\n\nPyhon\n\njukousei_df2['班番号'].isna().sum()\n#&gt; 0\n\n同様に条件1〜5についても検証しておきましょう。\n\n\nPyhon\n\n# 各班に社会人経験のある学生が3名以上含まれる\n# 以下の学生はばらばらの班になる\n#  → 各班に含まれる指名された学生の人数が1人ならOK\n# 各班に経済学研究科学生が1名以上2名以下含まれる\n#  → 各班に含まれる経済学研究科の学生が1人or2人ならOK\n\njukousei_df2['社会人経験なし'] = ~jukousei_df2['社会人経験あり']\n\nres = jukousei_df2.groupby('班番号')[['社会人経験あり', '理系', '指名学生']].sum()\n\nres['班員の総数'] = jukousei_df2.value_counts('班番号', sort = False)\nprint(res)\n#&gt;     社会人経験あり  理系  指名学生  班員の総数\n#&gt; 班番号                          \n#&gt; A              4       2         1           7\n#&gt; B              4       2         1           7\n#&gt; C              3       1         1           7\n#&gt; D              4       1         1           7\n#&gt; E              3       1         1           8\n\n最後に、班のメンバーを表示するコードを実装しておきます。\n\n\nPyhon\n\nfor g in ['A', 'B']:\n    han_list =  jukousei_df2.loc[jukousei_df2['班番号'] == g, '氏名'].to_list()\n    print(f'\\n{g}班')\n    for i in han_list:\n        print(f' {i}')\n#&gt; A班\n#&gt;  鈴木\n#&gt;  高橋\n#&gt;  山本\n#&gt;  阿部\n#&gt;  石井\n#&gt;  長谷川\n#&gt;  近藤\n\n#&gt; B班\n#&gt;  渡辺\n#&gt;  中村\n#&gt;  松本\n#&gt;  池田\n#&gt;  橋本\n#&gt;  石川\n#&gt;  藤田\n\nなお、ここでは紙幅の都合でA班とB班のみ表示してますがfor g in ['A', 'B'] の代わりに for g in groups とすることで、全ての班のメンバーを表示することができます。\n\n\n\n\n岩永二郎, 石原響太, 田中一樹, and 西村直樹. (2024). 『Pythonではじめる数理最適化(第2版): ケーススタディでモデリングのスキルを身につけよう』. オーム社. https://www.jikkyo.co.jp/book/detail/13147",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>プロジェクト2：制約付き最適化によるグループ分け</span>"
    ]
  },
  {
    "objectID": "90-references.html",
    "href": "90-references.html",
    "title": "References",
    "section": "",
    "text": "Bodory, Hugo, Lorenzo Camponovo, Martin Huber, and Michael Lechner.\n(2020). The finite sample performance of inference methods for\npropensity score matching and weighting estimators. Journal of\nBusiness & Economic Statistics, 38(1), 183–200.\n\n\nEfron, Bradley, and Trevor Hastie. (2016). Computer age statistical\ninference. Cambridge University Press. https://web.stanford.edu/~hastie/CASI/\nInstitute of mathematical statistics monographs\n\n\nHoffmann, Rodolfo, and Ana Lucia Kassouf. (2005). Deriving conditional\nand unconditional marginal effects in log earnings equations estimated\nby heckman’s procedure. Applied Economics, 37(11),\n1303–1311.\n\n\nTaddy, Matt. (2019). Business data science: Combining machine\nlearning and economics to optimize, automate, and accelerate business\ndecisions. McGraw-Hill Education. https://www.oreilly.com/library/view/business-data-science/9781260452785/\n上杉隼人,\n井上毅郎〔訳〕(2020)『ビジネスデータサイエンスの教科書』すばる舎\n\n\nダハナ・ウィラワン ドニ, and 勝又壮太郎. (2023).\n『Rによるマーケティング・データ分析: 基礎から応用まで (ライブラリ\nデータ分析への招待 4)』. 新世社.\n\n\n大森義明, and 永瀬伸子. (2021). 『労働経済学をつかむ』. 有斐閣.\n\n\n太田聰一, 玄田有史, and 近藤絢子. (2007).\n「溶けない氷河―世代効果の展望：時代を背負う労働者」.\n『日本労働研究雑誌』, 568, 97–112.\n\n\n岩永二郎, 石原響太, 田中一樹, and 西村直樹. (2024).\n『Pythonではじめる数理最適化(第2版):\nケーススタディでモデリングのスキルを身につけよう』. オーム社. https://www.jikkyo.co.jp/book/detail/13147\n\n\n川口大司. (2017). 『労働経済学 – 理論と実証をつなぐ』. 有斐閣.\n\n\n春山鉄源. (2023). Pythonで学ぶ入門計量経済学. https://py4etrics.github.io/index.html\n\n\n末石直也. (2015). 『計量経済学：ミクロデータ分析へのいざない』.\n日本評論社.",
    "crumbs": [
      "References"
    ]
  }
]